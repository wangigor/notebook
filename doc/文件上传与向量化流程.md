# 知识库Agent系统文件上传与向量化流程详解

## 一、文件上传流程

### 前端实现

#### 1. 上传组件实现（DocumentUploader.tsx）

前端使用`DocumentUploader`组件处理文件上传，主要功能包括：

```typescript
// 核心上传处理函数
const handleUpload = async () => {
  // 文件和表单验证
  if (!file || !fileName.trim()) {
    Toast.error('请选择要上传的文件并输入文档名称');
    return;
  }
  
  // 解析元数据
  let parsedMetadata = {};
  if (metadata && metadata.trim()) {
    try {
      parsedMetadata = JSON.parse(metadata);
    } catch (error) {
      Toast.error('元数据格式不正确，请输入有效的JSON');
      return;
    }
  }
  
  setUploadLoading(true);
  
  try {
    // 标准化文件对象
    let fileToUpload: File;
    
    if (file instanceof File) {
      fileToUpload = file;
    } else if (file && 'url' in file && typeof file.url === 'string' && file.url.startsWith('blob:')) {
      // 处理UI组件提供的特殊文件对象
      const response = await fetch(file.url);
      const blob = await response.blob();
      fileToUpload = new File([blob], file.name as string, { type: blob.type });
    } else {
      fileToUpload = file as any;
    }
    
    // 调用API上传文件
    const response = await documents.uploadDocument(fileToUpload, {
      name: fileName,
      ...parsedMetadata
    });
    
    // 处理响应
    if (response.success) {
      Toast.success('文档上传成功');
      resetForm();
      onClose();
      if (onSuccess) onSuccess();
    } else {
      Toast.error(response.message || '上传文档失败');
    }
  } catch (error: any) {
    Toast.error('上传文档失败: ' + (error.message || '未知错误'));
  } finally {
    setUploadLoading(false);
  }
};
```

#### 2. API客户端实现（api.ts）

前端通过API客户端与后端交互：

```typescript
// 文档上传API
uploadDocument: async (file: File, metadata?: any): Promise<ApiResponse<Document>> => {
  const formData = new FormData();
  formData.append('file', file);
  
  if (metadata) {
    formData.append('metadata', typeof metadata === 'string' ? metadata : JSON.stringify(metadata));
  }
  
  return api.post('/documents/upload', formData, {
    headers: {
      'Content-Type': 'multipart/form-data'
    }
  });
}
```

#### 3. 文件选择与表单

文件上传组件支持三种方式添加文档：
- 本地文件上传 - 使用`Upload`组件处理文件选择
- 网页URL导入 - 使用`WebDocumentForm`组件
- 自定义文档创建 - 使用`CustomDocumentForm`组件

### 后端实现

#### 1. 文件上传路由

系统提供两个上传端点：
- `/api/documents/upload` - 主文档上传端点
- `/api/agents/upload-file` - 代理端点（转发到文档API）

上传路由实现：
```python
@router.post("/upload", response_model=DocumentResponse)
async def upload_document(
    file: UploadFile = File(...),
    metadata: Optional[str] = Form(None),
    db: Session = Depends(get_db),
    document_service: DocumentService = Depends(get_document_service),
    current_user: User = Depends(get_current_user)
):
    """上传文档"""
    try:
        # 解析元数据
        parsed_metadata = {}
        if metadata:
            try:
                parsed_metadata = json.loads(metadata)
            except json.JSONDecodeError as e:
                parsed_metadata = {"notes": metadata}
        
        # 处理文件
        document = await document_service.process_file(
            file=file,
            user_id=current_user.id,
           doc_metadata=parsed_metadata
        )
        
        return document
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"上传文档失败: {str(e)}")
```

#### 2. 文件处理（process_file方法）

`DocumentService`类中的`process_file`方法处理文件：

```python
async def process_file(self, file: UploadFile, user_id: int, metadata: Optional[Dict[str, Any]] = None) -> Document:
    """处理上传文件"""
    # 获取文件内容
    content = await file.read()
    
    # 提取文本
    extracted_text = await self._extract_text_from_file(file.filename, file.content_type, content)
    
    # 获取文件类型
    file_extension = os.path.splitext(file.filename)[1].lower() if file.filename else ""
    file_type = file_extension.lstrip(".") or file.content_type or "unknown"
    
    # 处理二进制文件（Base64编码）
    binary_types = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'zip', 'rar']
    is_binary = file_type in binary_types
    
    if is_binary:
        content_to_save = f"__BASE64__{base64.b64encode(content).decode('ascii')}"
    else:
        content_to_save = content.decode('utf-8', errors='ignore')
    
    # 创建元数据
    file_metadata = {
        "filename": file.filename,
        "content_type": file.content_type,
        "size": len(content),
        "is_binary_encoded": is_binary,
        **(metadata or {})
    }
    
    # 创建文档（包含向量化处理）
    return await self.create_document(
        user_id=user_id,
        name=file.filename or "Unnamed document",
        file_type=file_type,
        content=content_to_save,
        extracted_text=extracted_text,
        metadata=file_metadata
    )
```

## 二、文本提取实现

系统能从不同类型的文件中提取文本，具体实现在`_extract_text_from_file`方法中：

```python
async def _extract_text_from_file(self, filename: Optional[str], content_type: Optional[str], content: bytes) -> str:
    """从文件中提取文本"""
    if not filename:
        return content.decode('utf-8', errors='ignore')
        
    file_ext = os.path.splitext(filename)[1].lower()
    
    # 根据文件类型使用不同的提取方法
    if file_ext in ['.txt']:
        # 纯文本文件
        return content.decode('utf-8', errors='ignore')
        
    elif file_ext in ['.pdf']:
        # PDF文件
        try:
            import PyPDF2
            from io import BytesIO
            
            pdf_reader = PyPDF2.PdfReader(BytesIO(content))
            text = ""
            for page in pdf_reader.pages:
                text += page.extract_text() + "\n"
            return text
        except Exception as e:
            print(f"PDF提取文本错误: {str(e)}")
            return content.decode('utf-8', errors='ignore')
            
    elif file_ext in ['.doc', '.docx']:
        # Word文档
        try:
            import docx
            from io import BytesIO
            
            doc = docx.Document(BytesIO(content))
            text = ""
            for paragraph in doc.paragraphs:
                text += paragraph.text + "\n"
            return text
        except Exception as e:
            print(f"Word提取文本错误: {str(e)}")
            return content.decode('utf-8', errors='ignore')
            
    # 更多文件类型处理...（CSV, Excel, HTML, JSON等）
    
    # 默认尝试解码为文本
    return content.decode('utf-8', errors='ignore')
```

系统支持多种文件格式的文本提取：
- PDF文件：使用PyPDF2库提取文本
- Word文档：使用python-docx库提取文本
- Excel文件：使用openpyxl库提取文本
- CSV文件：解析为文本并提取内容
- JSON文件：美化格式后返回
- HTML文件：使用BeautifulSoup提取纯文本内容
- 纯文本文件：直接解码

## 三、向量化处理

### 1. 向量化存储服务

系统使用`VectorStoreService`类处理向量化和存储：

```python
class VectorStoreService:
    """向量存储服务"""
    
    def __init__(self):
        self.is_mock_mode = False
        
        # 初始化DashScope Embedding
        try:
            self.embedding = DashScopeEmbeddings(
                model=settings.DASHSCOPE_EMBEDDING_MODEL,
                dashscope_api_key=settings.DASHSCOPE_API_KEY
            )
        except Exception as e:
            logger.error(f"初始化DashScopeEmbeddings失败: {str(e)}")
            raise
        
        # 初始化Qdrant客户端
        try:
            self.client = QdrantClient(
                url=settings.QDRANT_URL, 
                api_key=settings.QDRANT_API_KEY,
                timeout=settings.QDRANT_TIMEOUT
            )
            
            # 测试连接
            if not self._test_connection():
                raise ConnectionError("无法连接到Qdrant服务器")
                
        except Exception as e:
            logger.warning(f"连接到Qdrant服务器失败: {str(e)}. 切换到本地模拟模式.")
            self.is_mock_mode = True
        
        # 初始化向量存储
        if not self.is_mock_mode:
            try:
                self.vector_store = self._create_vector_store()
            except Exception as e:
                logger.error(f"创建向量存储失败: {str(e)}. 切换到本地模拟模式.")
                self.is_mock_mode = True
```

系统使用以下技术组合进行向量化：
- 嵌入模型：使用阿里云DashScope的嵌入模型（`text-embedding-v1`）
- 向量数据库：使用Qdrant进行向量存储和检索

### 2. 文档向量化流程

文档创建时的向量化处理在`create_document`方法中：

```python
async def create_document(self, user_id, name, file_type, content, extracted_text, metadata):
    # 生成唯一ID和创建数据库记录
    document_id = f"doc_{uuid.uuid4()}"
    db_document = Document(...)
    self.db.add(db_document)
    self.db.commit()
    
    # 添加到向量存储
    if extracted_text:
        # 限制文本长度在2048字符以内（符合模型限制）
        max_length = 2048
        if len(extracted_text) > max_length:
            text_for_vector = extracted_text[:max_length]
        else:
            text_for_vector = extracted_text
            
        # 构建向量元数据
        vector_metadata = {
            "document_id": document_id,
            "name": name,
            "file_type": file_type,
            **(metadata or {})
        }
        
        # 添加到向量存储
        vector_ids = self.vector_store.add_texts(
            texts=[text_for_vector],
            metadatas=[vector_metadata]
        )
        
        if vector_ids:
            # 更新向量ID
            db_document.vector_id = vector_ids[0]
            self.db.commit()
    
    return db_document
```

### 3. 向量存储实现

`add_texts`方法将文本转换为向量并存储：

```python
def add_texts(self, texts: List[str], metadatas: Optional[List[Dict[str, Any]]] = None) -> List[str]:
    """添加文本到向量存储"""
    if self.is_mock_mode:
        logger.info(f"模拟模式: 添加 {len(texts)} 条文本")
        return [f"mock-id-{i}" for i in range(len(texts))]
        
    if not self.vector_store:
        logger.error("向量存储未初始化，无法添加文本")
        return []
        
    try:
        logger.info(f"向向量存储添加 {len(texts)} 条文本...")
        # 内部使用DashScope的嵌入模型生成向量
        result = self.vector_store.add_texts(texts=texts, metadatas=metadatas)
        logger.info(f"成功添加 {len(result)} 条文本")
        return result
    except Exception as e:
        logger.error(f"添加文本到向量存储出错: {str(e)}")
        return [f"error-id-{i}" for i in range(len(texts))]
```

### 4. 向量检索实现

系统使用`similarity_search`方法进行相似度搜索：

```python
def similarity_search(self, query: str, k: int = 4) -> List[Dict[str, Any]]:
    """相似度搜索"""
    if not self.vector_store:
        return []
        
    try:
        # 使用向量存储的相似度搜索功能
        docs = self.vector_store.similarity_search(query, k=k)
        results = []
        
        for doc in docs:
            results.append({
                "content": doc.page_content,
                "metadata": doc.metadata
            })
        return results
    except Exception as e:
        logger.error(f"相似度搜索出错: {str(e)}")
        return []
```

## 四、关键技术点总结

1. **文件上传流程**：
   - 前端使用FormData处理文件上传
   - 后端使用FastAPI的File和Form处理文件和元数据
   - 支持多种文件格式（PDF、Word、Excel、文本等）

2. **文本提取技术**：
   - 使用专用库处理不同格式文件：PyPDF2、python-docx、openpyxl等
   - 二进制文件使用Base64编码存储
   - 文本长度限制在2048字符以内（符合嵌入模型限制）

3. **向量化处理**：
   - 使用阿里云DashScope的嵌入模型生成向量表示
   - 使用Qdrant作为向量数据库存储和检索
   - 检索时使用余弦相似度（COSINE）进行向量匹配

4. **元数据管理**：
   - 文档元数据支持JSON格式
   - 元数据与向量一同存储，便于检索和过滤
   - 在创建向量时会合并文档ID等系统元数据

5. **错误处理和模拟模式**：
   - 向量服务支持模拟模式，在无法连接向量数据库时自动切换
   - 提供详细的日志记录机制
   - 优雅处理各种异常情况

系统整体实现了一个完整的文档上传、文本提取、向量化和检索流程，能够支持基于文档内容的智能问答功能。 
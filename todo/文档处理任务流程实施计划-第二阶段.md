# 文档处理任务流程实施计划 - 第二阶段

## 第二阶段：Celery任务与WebSocket实现

### 一、Celery任务实现

#### 1. 主任务定义

**位置**: `notebook-backend/app/celery_tasks/document_processing.py`

```python
from celery import Celery, chain, group
from datetime import datetime
import os
import time
import random
import logging
from app.services.task_service import TaskService
from app.services.task_detail_service import TaskDetailService
from app.services.document_service import DocumentService
from app.models.task import TaskStatus, TaskStepType
from app.database import get_db

logger = logging.getLogger(__name__)
celery_app = Celery('document_tasks')

@celery_app.task(bind=True, name="process_document")
def process_document(self, document_id: str, task_id: str, file_path: str):
    """处理文档的主任务"""
    db = next(get_db())
    try:
        task_service = TaskService(db)
        task_detail_service = TaskDetailService(db)
        
        # 更新任务状态为运行中
        task_service.update_task(task_id, status=TaskStatus.RUNNING, started_at=datetime.utcnow())
        
        # 定义处理步骤
        steps = [
            {"name": "文件验证", "type": TaskStepType.FILE_UPLOAD, "order": 1},
            {"name": "文本提取", "type": TaskStepType.TEXT_EXTRACTION, "order": 2},
            {"name": "文本分块", "type": TaskStepType.TEXT_SPLITTING, "order": 3},
            {"name": "生成向量", "type": TaskStepType.EMBEDDING_GENERATION, "order": 4},
            {"name": "向量存储", "type": TaskStepType.VECTOR_STORAGE, "order": 5}
        ]
        
        # 创建任务详情记录
        task_details = []
        for step in steps:
            task_detail = task_detail_service.create_task_detail(
                task_id=task_id,
                step_name=step["name"],
                step_order=step["order"]
            )
            task_details.append(task_detail)
        
        # 构建子任务链
        subtasks = chain(
            validate_file.s(document_id, task_id, task_details[0].id, file_path),
            extract_text.s(document_id, task_id, task_details[1].id),
            split_text.s(document_id, task_id, task_details[2].id),
            generate_embeddings.s(document_id, task_id, task_details[3].id),
            store_vectors.s(document_id, task_id, task_details[4].id)
        )
        
        # 执行子任务链
        result = subtasks.apply_async()
        return {"status": "started", "task_id": task_id}
        
    except Exception as e:
        # 发生异常时更新任务状态
        task_service.update_task(
            task_id, 
            status=TaskStatus.FAILED, 
            error_message=str(e),
            completed_at=datetime.utcnow()
        )
        logger.error(f"处理文档任务失败: {str(e)}")
        raise
```

#### 2. 子任务实现

**位置**: `notebook-backend/app/celery_tasks/document_processing.py`

```python
@celery_app.task(bind=True, name="validate_file")
def validate_file(self, document_id: str, task_id: str, task_detail_id: int, file_path: str):
    """验证文件任务"""
    db = next(get_db())
    task_detail_service = TaskDetailService(db)
    task_service = TaskService(db)
    
    try:
        # 更新任务详情状态
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.RUNNING,
            progress=10
        )
        
        # TODO: 实现文件验证逻辑
        # 1. 检查文件是否存在
        # 2. 验证文件格式
        # 3. 检查文件大小
        
        # 模拟处理过程
        time.sleep(1)
        
        # 更新任务详情为完成
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.COMPLETED,
            progress=100,
            details={"file_size": os.path.getsize(file_path), "file_type": "pdf"}
        )
        
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        
        # 返回结果供下一个任务使用
        return {"document_id": document_id, "file_path": file_path, "validated": True}
    
    except Exception as e:
        # 更新任务详情为失败
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.FAILED,
            error_message=str(e)
        )
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        logger.error(f"验证文件任务失败: {str(e)}")
        raise

@celery_app.task(bind=True, name="extract_text")
def extract_text(self, result_from_previous: dict, document_id: str, task_id: str, task_detail_id: int):
    """提取文本任务"""
    db = next(get_db())
    task_detail_service = TaskDetailService(db)
    task_service = TaskService(db)
    
    try:
        # 更新任务详情状态
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.RUNNING,
            progress=10
        )
        
        file_path = result_from_previous.get("file_path")
        if not file_path:
            raise ValueError("File path not provided from previous task")
        
        # TODO: 实现文本提取逻辑
        # 1. 根据文件类型选择合适的提取器
        # 2. 提取文本内容
        # 3. 清理和预处理文本
        
        # 模拟处理过程
        time.sleep(2)
        extracted_text = "这是从文件中提取的示例文本内容。"
        
        # 更新任务详情为完成
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.COMPLETED,
            progress=100,
            details={"text_length": len(extracted_text)}
        )
        
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        
        # 返回结果供下一个任务使用
        result_from_previous.update({"extracted_text": extracted_text})
        return result_from_previous
    
    except Exception as e:
        # 更新任务详情为失败
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.FAILED,
            error_message=str(e)
        )
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        logger.error(f"提取文本任务失败: {str(e)}")
        raise

@celery_app.task(bind=True, name="split_text")
def split_text(self, result_from_previous: dict, document_id: str, task_id: str, task_detail_id: int):
    """文本分块任务"""
    db = next(get_db())
    task_detail_service = TaskDetailService(db)
    task_service = TaskService(db)
    
    try:
        # 更新任务详情状态
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.RUNNING,
            progress=10
        )
        
        text = result_from_previous.get("extracted_text")
        if not text:
            raise ValueError("Extracted text not provided from previous task")
        
        # TODO: 实现文本分块逻辑
        # 1. 根据配置确定分块策略
        # 2. 将文本分割成合适大小的块
        # 3. 确保语义完整性
        
        # 模拟处理过程
        time.sleep(1.5)
        chunks = [text[i:i+100] for i in range(0, len(text), 100)]
        
        # 更新任务详情为完成
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.COMPLETED,
            progress=100,
            details={"chunk_count": len(chunks)}
        )
        
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        
        # 返回结果供下一个任务使用
        result_from_previous.update({"chunks": chunks})
        return result_from_previous
    
    except Exception as e:
        # 更新任务详情为失败
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.FAILED,
            error_message=str(e)
        )
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        logger.error(f"文本分块任务失败: {str(e)}")
        raise

@celery_app.task(bind=True, name="generate_embeddings")
def generate_embeddings(self, result_from_previous: dict, document_id: str, task_id: str, task_detail_id: int):
    """生成向量嵌入任务"""
    db = next(get_db())
    task_detail_service = TaskDetailService(db)
    task_service = TaskService(db)
    
    try:
        # 更新任务详情状态
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.RUNNING,
            progress=10
        )
        
        chunks = result_from_previous.get("chunks")
        if not chunks:
            raise ValueError("Text chunks not provided from previous task")
        
        # TODO: 实现向量生成逻辑
        # 1. 批量处理文本块
        # 2. 调用嵌入模型API
        # 3. 处理和验证生成的向量
        
        # 模拟处理过程
        total_chunks = len(chunks)
        embeddings = []
        
        for i, chunk in enumerate(chunks):
            # 模拟向量生成
            time.sleep(0.5)
            # 生成随机向量作为示例
            embedding = [random.random() for _ in range(10)]
            embeddings.append(embedding)
            
            # 更新进度
            progress = int((i + 1) / total_chunks * 90) + 10
            task_detail_service.update_task_detail(
                task_detail_id,
                progress=progress,
                details={"processed_chunks": i + 1, "total_chunks": total_chunks}
            )
        
        # 更新任务详情为完成
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.COMPLETED,
            progress=100,
            details={"embedding_count": len(embeddings)}
        )
        
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        
        # 返回结果供下一个任务使用
        result_from_previous.update({"embeddings": embeddings})
        return result_from_previous
    
    except Exception as e:
        # 更新任务详情为失败
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.FAILED,
            error_message=str(e)
        )
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        logger.error(f"生成向量嵌入任务失败: {str(e)}")
        raise

@celery_app.task(bind=True, name="store_vectors")
def store_vectors(self, result_from_previous: dict, document_id: str, task_id: str, task_detail_id: int):
    """存储向量到向量数据库任务"""
    db = next(get_db())
    task_detail_service = TaskDetailService(db)
    task_service = TaskService(db)
    document_service = DocumentService(db)
    
    try:
        # 更新任务详情状态
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.RUNNING,
            progress=10
        )
        
        chunks = result_from_previous.get("chunks")
        embeddings = result_from_previous.get("embeddings")
        
        if not chunks or not embeddings:
            raise ValueError("Chunks or embeddings not provided from previous tasks")
        
        # TODO: 实现向量存储逻辑
        # 1. 连接向量数据库
        # 2. 批量插入向量
        # 3. 验证存储结果
        
        # 模拟处理过程
        time.sleep(2)
        
        # 更新任务详情为完成
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.COMPLETED,
            progress=100,
            details={"stored_vectors": len(embeddings)}
        )
        
        # 更新文档状态
        document_service.update_document_status(document_id, "AVAILABLE")
        
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        
        # 返回处理结果
        return {
            "document_id": document_id,
            "task_id": task_id,
            "status": "completed",
            "chunks_processed": len(chunks),
            "vectors_stored": len(embeddings)
        }
    
    except Exception as e:
        # 更新任务详情为失败
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.FAILED,
            error_message=str(e)
        )
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        logger.error(f"存储向量任务失败: {str(e)}")
        raise
```

#### 3. Celery配置

**位置**: `notebook-backend/app/celery_config.py`

```python
from app.config import settings

# Celery配置
broker_url = settings.CELERY_BROKER_URL
result_backend = settings.CELERY_RESULT_BACKEND

# 任务序列化格式
task_serializer = 'json'
result_serializer = 'json'
accept_content = ['json']

# 任务执行设置
task_acks_late = True
worker_prefetch_multiplier = 1
task_track_started = True

# 日志配置
worker_redirect_stdouts = False
worker_redirect_stdouts_level = 'INFO'

# 任务路由
task_routes = {
    'process_document': {'queue': 'document_processing'},
    'validate_file': {'queue': 'document_processing'},
    'extract_text': {'queue': 'document_processing'},
    'split_text': {'queue': 'document_processing'},
    'generate_embeddings': {'queue': 'document_processing'},
    'store_vectors': {'queue': 'document_processing'},
}

# 任务软时间限制 (秒)
task_soft_time_limit = 600
# 任务硬时间限制 (秒)
task_time_limit = 1200

# 预定任务设置
beat_schedule = {}
```

### 二、WebSocket实现

#### 1. WebSocket连接管理

**位置**: `notebook-backend/app/websockets/task_manager.py`

```python
import json
import logging
from typing import Dict, List, Any, Optional
from fastapi import WebSocket, WebSocketDisconnect
from app.models.task import Task, TaskDetail

logger = logging.getLogger(__name__)

class ConnectionManager:
    """WebSocket连接管理器"""
    
    def __init__(self):
        self.active_connections: Dict[str, List[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, task_id: str):
        """添加新的WebSocket连接"""
        await websocket.accept()
        if task_id not in self.active_connections:
            self.active_connections[task_id] = []
        self.active_connections[task_id].append(websocket)
        logger.info(f"新的WebSocket连接: {task_id}, 当前连接数: {len(self.active_connections[task_id])}")
    
    def disconnect(self, websocket: WebSocket, task_id: str):
        """移除WebSocket连接"""
        if task_id in self.active_connections:
            if websocket in self.active_connections[task_id]:
                self.active_connections[task_id].remove(websocket)
            # 如果没有活跃连接，则移除任务ID
            if not self.active_connections[task_id]:
                del self.active_connections[task_id]
            logger.info(f"WebSocket连接断开: {task_id}, 剩余连接数: {len(self.active_connections.get(task_id, []))}")
    
    async def broadcast_task_update(self, task_id: str, data: Dict[str, Any]):
        """广播任务更新消息"""
        if task_id in self.active_connections:
            # 序列化数据为JSON字符串
            message = json.dumps(data)
            for connection in self.active_connections[task_id]:
                try:
                    await connection.send_text(message)
                except Exception as e:
                    logger.error(f"发送WebSocket消息失败: {str(e)}")
    
    async def send_personal_message(self, websocket: WebSocket, message: str):
        """发送个人消息"""
        try:
            await websocket.send_text(message)
        except Exception as e:
            logger.error(f"发送个人WebSocket消息失败: {str(e)}")


# 创建全局连接管理器实例
connection_manager = ConnectionManager()
```

#### 2. WebSocket端点

**位置**: `notebook-backend/app/websockets/task_manager.py`

```python
async def task_websocket_endpoint(websocket: WebSocket, task_id: str):
    """任务WebSocket端点"""
    await connection_manager.connect(websocket, task_id)
    try:
        while True:
            # 等待前端消息（虽然在这个应用中前端可能不发送消息）
            data = await websocket.receive_text()
            # 对接收到的消息做处理，通常是控制命令
            await handle_websocket_message(websocket, task_id, data)
    except WebSocketDisconnect:
        connection_manager.disconnect(websocket, task_id)


async def handle_websocket_message(websocket: WebSocket, task_id: str, message: str):
    """处理从WebSocket接收到的消息"""
    try:
        data = json.loads(message)
        command = data.get("command")
        
        if command == "ping":
            # 心跳检测
            await connection_manager.send_personal_message(websocket, json.dumps({"command": "pong"}))
        elif command == "cancel":
            # 取消任务
            # TODO: 实现任务取消逻辑
            pass
        else:
            # 未知命令
            await connection_manager.send_personal_message(
                websocket, 
                json.dumps({"error": "Unknown command"})
            )
    except json.JSONDecodeError:
        await connection_manager.send_personal_message(
            websocket, 
            json.dumps({"error": "Invalid JSON format"})
        )
    except Exception as e:
        logger.error(f"处理WebSocket消息时出错: {str(e)}")
        await connection_manager.send_personal_message(
            websocket, 
            json.dumps({"error": f"Internal error: {str(e)}"})
        )
```

#### 3. 任务状态推送

**位置**: `notebook-backend/app/websockets/task_manager.py`

```python
async def push_task_update(task_id: str, task_service, task_detail_service=None):
    """推送任务更新到WebSocket客户端"""
    try:
        # 获取任务信息
        task = task_service.get_task_by_id(task_id)
        if not task:
            logger.error(f"推送任务更新失败: 任务 {task_id} 不存在")
            return
        
        # 获取任务详情
        task_details = []
        if task_detail_service:
            task_details = task_detail_service.get_task_details_by_task_id(task_id)
        
        # 准备数据
        task_data = {
            "task_id": task.id,
            "status": task.status,
            "progress": task.progress,
            "error_message": task.error_message,
            "task_details": [
                {
                    "id": detail.id,
                    "step_name": detail.step_name,
                    "step_order": detail.step_order,
                    "status": detail.status,
                    "progress": detail.progress,
                    "error_message": detail.error_message,
                    "started_at": detail.started_at.isoformat() if detail.started_at else None,
                    "completed_at": detail.completed_at.isoformat() if detail.completed_at else None
                }
                for detail in task_details
            ] if task_details else []
        }
        
        # 广播更新
        await connection_manager.broadcast_task_update(task_id, task_data)
        
    except Exception as e:
        logger.error(f"推送任务更新失败: {str(e)}")
```

#### 4. 集成到任务执行过程

在Celery任务中添加WebSocket推送:

```python
# 在Celery任务开始时添加
await push_task_update(task_id, task_service, task_detail_service)

# 在任务状态更新后添加
task_service.update_task_status_based_on_details(task_id)
await push_task_update(task_id, task_service, task_detail_service)
```

### 三、应用集成

#### 1. 注册WebSocket路由

**位置**: `notebook-backend/app/main.py`

```python
from fastapi import FastAPI
from app.api.endpoints import documents, tasks
from app.websockets.task_manager import task_websocket_endpoint

app = FastAPI(title="文档处理系统")

# 注册API路由
app.include_router(documents.router, prefix="/api/documents", tags=["documents"])
app.include_router(tasks.router, prefix="/api/tasks", tags=["tasks"])

# 注册WebSocket路由
app.websocket("/ws/tasks/{task_id}")(task_websocket_endpoint)
```

#### 2. 创建Celery实例

**位置**: `notebook-backend/app/celery_app.py`

```python
from celery import Celery
from app.celery_config import *

# 创建Celery实例
celery_app = Celery("notebook_app")

# 加载配置
celery_app.config_from_object("app.celery_config")

# 可选：自动发现任务
celery_app.autodiscover_tasks(["app.celery_tasks"])
```

### 四、第二阶段实施步骤

1. 实现Celery任务处理链
   1.1. 创建主任务和子任务
   1.2. 实现任务状态更新逻辑
   1.3. 添加错误处理和恢复机制

2. 实现WebSocket通知系统
   2.1. 创建WebSocket连接管理器
   2.2. 实现任务状态推送功能
   2.3. 实现WebSocket端点

3. 集成到应用
   3.1. 注册WebSocket路由
   3.2. 配置Celery应用
   3.3. 更新任务处理流程

### 五、测试验证

1. 测试Celery任务链
   - 验证任务创建和执行
   - 验证任务状态更新
   - 验证错误处理机制

2. 测试WebSocket通知
   - 验证WebSocket连接建立
   - 验证实时状态更新推送
   - 验证客户端断开连接处理

3. 集成测试
   - 验证完整的文档处理流程
   - 验证任务状态实时更新
   - 验证异常情况的处理 
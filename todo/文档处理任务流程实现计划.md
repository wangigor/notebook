# 文档处理任务流程实现计划

## 概述

本文档详细描述了文档上传处理流程的实现计划，包括后端文件上传至Minio、创建Task记录、Celery Worker处理任务、生成并更新Task_detail记录等环节。

## 数据模型实现

### 1. TaskDetail SQLAlchemy模型（后端）

**位置**: `notebook-backend/app/models/task.py`

```python
class TaskDetail(Base):
    """任务详情数据模型"""
    __tablename__ = "task_details"

    id = Column(Integer, primary_key=True, autoincrement=True)
    task_id = Column(String(36), ForeignKey("tasks.id"), nullable=True)
    step_name = Column(String(50), nullable=False)  # 步骤名称
    step_order = Column(Integer, nullable=False)  # 步骤顺序
    status = Column(String(20), nullable=False, default=TaskStatus.PENDING)  # 步骤状态
    progress = Column(Integer, nullable=False, default=0)  # 步骤进度（0-100）
    details = Column(JSON, nullable=True)  # 步骤详细信息
    error_message = Column(Text, nullable=True)  # 错误信息
    started_at = Column(DateTime, nullable=True)  # 开始时间
    completed_at = Column(DateTime, nullable=True)  # 完成时间
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)  # 创建时间
    
    # 与Task的关系
    task = relationship("Task", back_populates="task_details")

    # 添加索引
    __table_args__ = (
        Index('idx_task_details_task_id', 'task_id'),
        Index('idx_task_details_status', 'status'),
    )
```

### 2. 修改Task模型添加关系（后端）

**位置**: `notebook-backend/app/models/task.py`

```python
class Task(Base):
    # 现有字段保持不变
    
    # 添加关系
    task_details = relationship("TaskDetail", back_populates="task", cascade="all, delete-orphan")
```

### 3. Pydantic模型（后端）

**位置**: `notebook-backend/app/models/task.py`

```python
class TaskDetailBase(BaseModel):
    """任务详情基础模型"""
    step_name: str
    step_order: int
    status: str = TaskStatus.PENDING
    progress: int = 0
    details: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)

class TaskDetailCreate(TaskDetailBase):
    """任务详情创建模型"""
    task_id: str

class TaskDetailUpdate(BaseModel):
    """任务详情更新模型"""
    status: Optional[str] = None
    progress: Optional[int] = None
    details: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)

class TaskDetailResponse(TaskDetailBase):
    """任务详情响应模型"""
    id: int
    task_id: str
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    created_at: datetime

    model_config = ConfigDict(from_attributes=True)
```

## 服务层实现

### 1. TaskDetail服务（后端）

**位置**: `notebook-backend/app/services/task_detail_service.py`

```python
class TaskDetailService:
    def __init__(self, db: Session):
        self.db = db

    def create_task_detail(self, task_id: str, step_name: str, step_order: int) -> TaskDetail:
        """创建任务详情记录"""
        task_detail = TaskDetail(
            task_id=task_id,
            step_name=step_name,
            step_order=step_order,
            status=TaskStatus.PENDING,
            progress=0
        )
        self.db.add(task_detail)
        self.db.commit()
        self.db.refresh(task_detail)
        return task_detail

    def update_task_detail(
        self, 
        task_detail_id: int, 
        status: Optional[str] = None,
        progress: Optional[int] = None,
        details: Optional[Dict[str, Any]] = None,
        error_message: Optional[str] = None
    ) -> TaskDetail:
        """更新任务详情状态和进度"""
        task_detail = self.db.query(TaskDetail).filter(TaskDetail.id == task_detail_id).first()
        if not task_detail:
            raise ValueError(f"TaskDetail with id {task_detail_id} not found")

        update_data = {}
        if status:
            update_data["status"] = status
            if status == TaskStatus.RUNNING and not task_detail.started_at:
                update_data["started_at"] = datetime.utcnow()
            elif status in [TaskStatus.COMPLETED, TaskStatus.FAILED]:
                update_data["completed_at"] = datetime.utcnow()
        
        if progress is not None:
            update_data["progress"] = progress
        
        if details:
            # 合并现有details和新details
            current_details = task_detail.details or {}
            current_details.update(details)
            update_data["details"] = current_details
        
        if error_message:
            update_data["error_message"] = error_message

        # 更新任务详情
        for key, value in update_data.items():
            setattr(task_detail, key, value)
        
        self.db.commit()
        self.db.refresh(task_detail)
        return task_detail

    def get_task_details_by_task_id(self, task_id: str) -> List[TaskDetail]:
        """获取任务的所有详情记录"""
        return self.db.query(TaskDetail).filter(TaskDetail.task_id == task_id).order_by(TaskDetail.step_order).all()

    def check_all_task_details_completed(self, task_id: str) -> bool:
        """检查任务的所有详情是否已完成"""
        task_details = self.get_task_details_by_task_id(task_id)
        if not task_details:
            return False
        
        return all(td.status == TaskStatus.COMPLETED for td in task_details)
```

### 2. 更新Task服务（后端）

**位置**: `notebook-backend/app/services/task_service.py`

```python
def update_task_status_based_on_details(self, task_id: str) -> Task:
    """根据任务详情更新任务状态"""
    task = self.get_task_by_id(task_id)
    if not task:
        raise ValueError(f"Task with id {task_id} not found")

    # 获取所有task_details
    task_details = self.db.query(TaskDetail).filter(TaskDetail.task_id == task_id).all()
    if not task_details:
        return task

    # 计算总进度
    if task_details:
        completed_count = sum(1 for td in task_details if td.status == TaskStatus.COMPLETED)
        total_progress = sum(td.progress for td in task_details) / len(task_details)
        
        # 更新任务状态
        if any(td.status == TaskStatus.FAILED for td in task_details):
            # 有任何一个步骤失败，整个任务失败
            error_messages = [td.error_message for td in task_details if td.error_message]
            task.status = TaskStatus.FAILED
            task.error_message = "; ".join(error_messages)
            task.completed_at = datetime.utcnow()
        elif all(td.status == TaskStatus.COMPLETED for td in task_details):
            # 所有步骤完成，整个任务完成
            task.status = TaskStatus.COMPLETED
            task.progress = 100.0
            task.completed_at = datetime.utcnow()
        elif any(td.status == TaskStatus.RUNNING for td in task_details):
            # 有步骤在运行，整个任务在运行
            task.status = TaskStatus.RUNNING
            task.progress = total_progress
            if not task.started_at:
                task.started_at = datetime.utcnow()
    
    self.db.commit()
    self.db.refresh(task)
    return task
```

## Celery任务实现

### 1. 主任务定义（后端）

**位置**: `notebook-backend/app/celery_tasks/document_processing.py`

```python
from celery import Celery, chain, group
from app.services.task_service import TaskService
from app.services.task_detail_service import TaskDetailService
from app.services.document_service import DocumentService
from app.models.task import TaskStatus, TaskStepType
from app.database import get_db

celery_app = Celery('document_tasks')

@celery_app.task(bind=True, name="process_document")
def process_document(self, document_id: str, task_id: str, file_path: str):
    """处理文档的主任务"""
    db = next(get_db())
    try:
        task_service = TaskService(db)
        task_detail_service = TaskDetailService(db)
        
        # 更新任务状态为运行中
        task_service.update_task(task_id, status=TaskStatus.RUNNING, started_at=datetime.utcnow())
        
        # 定义处理步骤
        steps = [
            {"name": "文件验证", "type": TaskStepType.FILE_UPLOAD, "order": 1},
            {"name": "文本提取", "type": TaskStepType.TEXT_EXTRACTION, "order": 2},
            {"name": "文本分块", "type": TaskStepType.TEXT_SPLITTING, "order": 3},
            {"name": "生成向量", "type": TaskStepType.EMBEDDING_GENERATION, "order": 4},
            {"name": "向量存储", "type": TaskStepType.VECTOR_STORAGE, "order": 5}
        ]
        
        # 创建任务详情记录
        task_details = []
        for step in steps:
            task_detail = task_detail_service.create_task_detail(
                task_id=task_id,
                step_name=step["name"],
                step_order=step["order"]
            )
            task_details.append(task_detail)
        
        # 构建子任务链
        subtasks = chain(
            validate_file.s(document_id, task_id, task_details[0].id, file_path),
            extract_text.s(document_id, task_id, task_details[1].id),
            split_text.s(document_id, task_id, task_details[2].id),
            generate_embeddings.s(document_id, task_id, task_details[3].id),
            store_vectors.s(document_id, task_id, task_details[4].id)
        )
        
        # 执行子任务链
        result = subtasks.apply_async()
        return {"status": "started", "task_id": task_id}
        
    except Exception as e:
        # 发生异常时更新任务状态
        task_service.update_task(
            task_id, 
            status=TaskStatus.FAILED, 
            error_message=str(e),
            completed_at=datetime.utcnow()
        )
        raise
```

### 2. 子任务实现（后端）

**位置**: `notebook-backend/app/celery_tasks/document_processing.py`

```python
@celery_app.task(bind=True, name="validate_file")
def validate_file(self, document_id: str, task_id: str, task_detail_id: int, file_path: str):
    """验证文件任务"""
    db = next(get_db())
    task_detail_service = TaskDetailService(db)
    
    try:
        # 更新任务详情状态
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.RUNNING,
            progress=10
        )
        
        # TODO: 实现文件验证逻辑
        # 1. 检查文件是否存在
        # 2. 验证文件格式
        # 3. 检查文件大小
        
        # 模拟处理过程
        time.sleep(1)
        
        # 更新任务详情为完成
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.COMPLETED,
            progress=100,
            details={"file_size": os.path.getsize(file_path), "file_type": "pdf"}
        )
        
        # 返回结果供下一个任务使用
        return {"document_id": document_id, "file_path": file_path, "validated": True}
    
    except Exception as e:
        # 更新任务详情为失败
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.FAILED,
            error_message=str(e)
        )
        # 更新主任务状态
        task_service = TaskService(db)
        task_service.update_task_status_based_on_details(task_id)
        raise

@celery_app.task(bind=True, name="extract_text")
def extract_text(self, result_from_previous: dict, document_id: str, task_id: str, task_detail_id: int):
    """提取文本任务"""
    db = next(get_db())
    task_detail_service = TaskDetailService(db)
    
    try:
        # 更新任务详情状态
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.RUNNING,
            progress=10
        )
        
        file_path = result_from_previous.get("file_path")
        if not file_path:
            raise ValueError("File path not provided from previous task")
        
        # TODO: 实现文本提取逻辑
        # 1. 根据文件类型选择合适的提取器
        # 2. 提取文本内容
        # 3. 清理和预处理文本
        
        # 模拟处理过程
        time.sleep(2)
        extracted_text = "这是从文件中提取的示例文本内容。"
        
        # 更新任务详情为完成
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.COMPLETED,
            progress=100,
            details={"text_length": len(extracted_text)}
        )
        
        # 返回结果供下一个任务使用
        result_from_previous.update({"extracted_text": extracted_text})
        return result_from_previous
    
    except Exception as e:
        # 更新任务详情为失败
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.FAILED,
            error_message=str(e)
        )
        # 更新主任务状态
        task_service = TaskService(db)
        task_service.update_task_status_based_on_details(task_id)
        raise

@celery_app.task(bind=True, name="split_text")
def split_text(self, result_from_previous: dict, document_id: str, task_id: str, task_detail_id: int):
    """文本分块任务"""
    db = next(get_db())
    task_detail_service = TaskDetailService(db)
    
    try:
        # 更新任务详情状态
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.RUNNING,
            progress=10
        )
        
        text = result_from_previous.get("extracted_text")
        if not text:
            raise ValueError("Extracted text not provided from previous task")
        
        # TODO: 实现文本分块逻辑
        # 1. 根据配置确定分块策略
        # 2. 将文本分割成合适大小的块
        # 3. 确保语义完整性
        
        # 模拟处理过程
        time.sleep(1.5)
        chunks = [text[i:i+100] for i in range(0, len(text), 100)]
        
        # 更新任务详情为完成
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.COMPLETED,
            progress=100,
            details={"chunk_count": len(chunks)}
        )
        
        # 返回结果供下一个任务使用
        result_from_previous.update({"chunks": chunks})
        return result_from_previous
    
    except Exception as e:
        # 更新任务详情为失败
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.FAILED,
            error_message=str(e)
        )
        # 更新主任务状态
        task_service = TaskService(db)
        task_service.update_task_status_based_on_details(task_id)
        raise

@celery_app.task(bind=True, name="generate_embeddings")
def generate_embeddings(self, result_from_previous: dict, document_id: str, task_id: str, task_detail_id: int):
    """生成向量嵌入任务"""
    db = next(get_db())
    task_detail_service = TaskDetailService(db)
    
    try:
        # 更新任务详情状态
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.RUNNING,
            progress=10
        )
        
        chunks = result_from_previous.get("chunks")
        if not chunks:
            raise ValueError("Text chunks not provided from previous task")
        
        # TODO: 实现向量生成逻辑
        # 1. 批量处理文本块
        # 2. 调用嵌入模型API
        # 3. 处理和验证生成的向量
        
        # 模拟处理过程
        total_chunks = len(chunks)
        embeddings = []
        
        for i, chunk in enumerate(chunks):
            # 模拟向量生成
            time.sleep(0.5)
            # 生成随机向量作为示例
            embedding = [random.random() for _ in range(10)]
            embeddings.append(embedding)
            
            # 更新进度
            progress = int((i + 1) / total_chunks * 90) + 10
            task_detail_service.update_task_detail(
                task_detail_id,
                progress=progress,
                details={"processed_chunks": i + 1, "total_chunks": total_chunks}
            )
        
        # 更新任务详情为完成
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.COMPLETED,
            progress=100,
            details={"embedding_count": len(embeddings)}
        )
        
        # 返回结果供下一个任务使用
        result_from_previous.update({"embeddings": embeddings})
        return result_from_previous
    
    except Exception as e:
        # 更新任务详情为失败
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.FAILED,
            error_message=str(e)
        )
        # 更新主任务状态
        task_service = TaskService(db)
        task_service.update_task_status_based_on_details(task_id)
        raise

@celery_app.task(bind=True, name="store_vectors")
def store_vectors(self, result_from_previous: dict, document_id: str, task_id: str, task_detail_id: int):
    """存储向量到向量数据库任务"""
    db = next(get_db())
    task_detail_service = TaskDetailService(db)
    task_service = TaskService(db)
    
    try:
        # 更新任务详情状态
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.RUNNING,
            progress=10
        )
        
        chunks = result_from_previous.get("chunks")
        embeddings = result_from_previous.get("embeddings")
        
        if not chunks or not embeddings:
            raise ValueError("Chunks or embeddings not provided from previous tasks")
        
        # TODO: 实现向量存储逻辑
        # 1. 连接向量数据库
        # 2. 批量插入向量
        # 3. 验证存储结果
        
        # 模拟处理过程
        time.sleep(2)
        
        # 更新任务详情为完成
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.COMPLETED,
            progress=100,
            details={"stored_vectors": len(embeddings)}
        )
        
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        
        # 返回处理结果
        return {
            "document_id": document_id,
            "task_id": task_id,
            "status": "completed",
            "chunks_processed": len(chunks),
            "vectors_stored": len(embeddings)
        }
    
    except Exception as e:
        # 更新任务详情为失败
        task_detail_service.update_task_detail(
            task_detail_id,
            status=TaskStatus.FAILED,
            error_message=str(e)
        )
        # 更新主任务状态
        task_service.update_task_status_based_on_details(task_id)
        raise
``` 
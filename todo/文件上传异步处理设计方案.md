# 文件上传与向量化异步处理系统开发方案

## 一、数据库设计

### 1. Tasks表
```sql
CREATE TABLE tasks (
    id VARCHAR(36) PRIMARY KEY,
    document_id INTEGER REFERENCES documents(id),
    type VARCHAR(50) NOT NULL, -- 'DOCUMENT_UPLOAD'
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING', -- 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED'
    overall_progress INTEGER DEFAULT 0,
    error_message TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    estimated_completion_time TIMESTAMP,
    created_by INTEGER REFERENCES users(id)
);
```

### 2. Task_Details表
```sql
CREATE TABLE task_details (
    id SERIAL PRIMARY KEY,
    task_id VARCHAR(36) REFERENCES tasks(id),
    step_name VARCHAR(50) NOT NULL, -- 'UPLOAD', 'VALIDATE', 'EXTRACT_TEXT', 'PREPROCESS', 'VECTORIZE', 'STORE'
    step_order INTEGER NOT NULL, -- 排序用
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING', -- 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'SKIPPED'
    progress INTEGER DEFAULT 0,
    details JSONB,
    error_message TEXT,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

### 3. Documents表修改
```sql
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    file_type VARCHAR(50),
    user_id INTEGER REFERENCES users(id),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    metadata JSONB,
    task_id VARCHAR(36) REFERENCES tasks(id),
    processing_status VARCHAR(20) DEFAULT 'PENDING',
    -- MinIO存储相关字段
    bucket_name VARCHAR(100),
    object_key VARCHAR(255),
    content_type VARCHAR(100),
    file_size BIGINT,
    etag VARCHAR(100),
    -- 向量索引相关
    vector_store_id VARCHAR(255)
);
```

## 二、后端API设计

### 1. 文档上传API
```python
@router.post("/documents/upload", response_model=DocumentUploadResponse)
async def upload_document(
    file: UploadFile = File(...),
    metadata: Optional[str] = Form(None),
    db: Session = Depends(get_db),
    document_service: DocumentService = Depends(get_document_service),
    current_user: User = Depends(get_current_user)
):
    """上传文档并启动异步处理任务"""
    try:
        # 保存文件到临时存储
        temp_file_path = await save_upload_file_temp(file)
        
        # 创建文档记录
        document = await document_service.create_document_record(
            user_id=current_user.id,
            name=file.filename or "未命名文档",
            file_type=get_file_extension(file.filename),
            metadata=parse_metadata(metadata),
            content_type=file.content_type
        )
        
        # 创建任务记录
        task_id = str(uuid.uuid4())
        task = await document_service.create_upload_task(
            task_id=task_id,
            document_id=document.id,
            user_id=current_user.id,
            file_path=temp_file_path,
            file_name=file.filename,
            content_type=file.content_type
        )
        
        # 启动异步处理任务
        process_document.delay(document.id, task.id, temp_file_path)
        
        return {
            "success": True,
            "document_id": document.id,
            "task_id": task.id,
            "message": "文档上传成功，正在处理中"
        }
    except Exception as e:
        logger.error(f"上传文档失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"上传文档失败: {str(e)}")
```

### 2. 文档下载API
```python
@router.get("/documents/{document_id}/download")
async def download_document(
    document_id: int,
    db: Session = Depends(get_db),
    document_service: DocumentService = Depends(get_document_service),
    storage_service: StorageService = Depends(get_storage_service),
    current_user: User = Depends(get_current_user)
):
    """获取文档下载链接"""
    # 获取文档信息
    document = await document_service.get_document_by_id(document_id)
    
    if not document:
        raise HTTPException(status_code=404, detail="文档不存在")
    
    # 检查权限
    if document.user_id != current_user.id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权访问此文档")
    
    # 检查文档是否已存储到MinIO
    if not document.object_key or not document.bucket_name:
        raise HTTPException(status_code=400, detail="文档尚未完成处理或不可下载")
    
    # 生成预签名下载URL
    try:
        presigned_url = await storage_service.generate_presigned_url(
            bucket_name=document.bucket_name,
            object_key=document.object_key,
            expires=3600  # 链接有效期1小时
        )
        
        return {
            "success": True,
            "document_name": document.name,
            "download_url": presigned_url,
            "expires_in": 3600
        }
    except Exception as e:
        logger.error(f"生成下载链接失败: {str(e)}")
        raise HTTPException(status_code=500, detail=f"生成下载链接失败: {str(e)}")
```

### 3. 任务状态查询API
```python
@router.get("/tasks/{task_id}", response_model=TaskStatusResponse)
async def get_task_status(
    task_id: str,
    db: Session = Depends(get_db),
    task_service: TaskService = Depends(get_task_service),
    current_user: User = Depends(get_current_user)
):
    """获取任务状态"""
    task = await task_service.get_task_with_details(task_id)
    
    if not task:
        raise HTTPException(status_code=404, detail="任务不存在")
    
    # 检查权限
    if task.document.user_id != current_user.id and not current_user.is_admin:
        raise HTTPException(status_code=403, detail="无权访问此任务")
    
    return task
```

### 4. WebSocket连接端点
```python
@app.websocket("/ws/tasks/{task_id}")
async def websocket_task_endpoint(
    websocket: WebSocket, 
    task_id: str,
    token: str = Query(...),
    task_service: TaskService = Depends(get_task_service)
):
    # 验证用户权限
    try:
        user = get_user_from_token(token)
        task = await task_service.get_task_by_id(task_id)
        
        if not task or (task.document.user_id != user.id and not user.is_admin):
            await websocket.close(code=4003)
            return
    except:
        await websocket.close(code=4001)
        return
    
    # 建立连接
    await manager.connect(websocket, task_id)
    
    # 发送当前状态
    current_status = await task_service.get_task_with_details(task_id)
    await websocket.send_json({
        "event": "task_update",
        "data": current_status
    })
    
    try:
        # 保持连接
        while True:
            data = await websocket.receive_text()
            # 可选：处理客户端命令，如取消任务
    except WebSocketDisconnect:
        manager.disconnect(websocket, task_id)
```

## 三、存储服务实现

### 1. MinIO存储服务
```python
from minio import Minio
from minio.error import S3Error
from app.core.config import settings
import os
import uuid
import tempfile

class StorageService:
    """MinIO对象存储服务"""
    
    def __init__(self):
        """初始化MinIO客户端"""
        self.client = Minio(
            endpoint=settings.MINIO_ENDPOINT,
            access_key=settings.MINIO_ACCESS_KEY,
            secret_key=settings.MINIO_SECRET_KEY,
            secure=settings.MINIO_SECURE,  # 是否使用HTTPS
        )
        self._ensure_buckets_exist()
    
    def _ensure_buckets_exist(self):
        """确保必要的存储桶存在"""
        document_bucket = settings.MINIO_DOCUMENT_BUCKET
        if not self.client.bucket_exists(document_bucket):
            self.client.make_bucket(document_bucket)
            logger.info(f"创建MinIO存储桶: {document_bucket}")
    
    async def upload_file_and_update_document(self, document_id, **kwargs):
        """
        上传文件到MinIO并更新文档记录
        
        参数:
            document_id: 文档ID
            kwargs: 其他参数，包括文件路径
            
        返回:
            上传结果信息
        """
        document_service = get_document_service()
        document = await document_service.get_document_by_id(document_id)
        
        if not document:
            raise ValueError(f"文档不存在: {document_id}")
        
        file_path = kwargs.get("file_path")
        if not file_path or not os.path.exists(file_path):
            raise ValueError(f"文件路径无效: {file_path}")
        
        content_type = kwargs.get("content_type") or document.content_type or "application/octet-stream"
        
        try:
            # 生成唯一对象键
            file_name = os.path.basename(file_path)
            object_key = f"{document.user_id}/{uuid.uuid4()}/{file_name}"
            
            # 上传文件到MinIO
            result = self.client.fput_object(
                bucket_name=settings.MINIO_DOCUMENT_BUCKET,
                object_name=object_key,
                file_path=file_path,
                content_type=content_type
            )
            
            # 获取文件大小
            file_size = os.path.getsize(file_path)
            
            # 更新文档记录
            await document_service.update_document_storage_info(
                document_id=document_id,
                bucket_name=settings.MINIO_DOCUMENT_BUCKET,
                object_key=object_key,
                content_type=content_type,
                file_size=file_size,
                etag=result.etag
            )
            
            return {
                "bucket_name": settings.MINIO_DOCUMENT_BUCKET,
                "object_key": object_key,
                "content_type": content_type,
                "file_size": file_size,
                "etag": result.etag
            }
            
        except S3Error as e:
            logger.error(f"MinIO上传错误: {str(e)}")
            raise Exception(f"文件上传到存储服务失败: {str(e)}")
    
    async def download_to_temp(self, bucket_name, object_key):
        """
        从MinIO下载文件到临时目录
        
        参数:
            bucket_name: 桶名称
            object_key: 对象键
            
        返回:
            临时文件路径
        """
        try:
            # 创建临时文件
            temp_dir = tempfile.mkdtemp()
            file_name = os.path.basename(object_key)
            temp_file_path = os.path.join(temp_dir, file_name)
            
            # 下载文件
            self.client.fget_object(
                bucket_name=bucket_name,
                object_name=object_key,
                file_path=temp_file_path
            )
            
            return temp_file_path
            
        except S3Error as e:
            logger.error(f"MinIO下载错误: {str(e)}")
            raise Exception(f"从存储服务下载文件失败: {str(e)}")
    
    async def generate_presigned_url(self, bucket_name, object_key, expires=3600):
        """
        生成预签名URL用于临时访问
        
        参数:
            bucket_name: 桶名称
            object_key: 对象键
            expires: 过期时间(秒)，默认1小时
            
        返回:
            预签名URL字符串
        """
        try:
            url = self.client.presigned_get_object(
                bucket_name=bucket_name,
                object_name=object_key,
                expires=expires
            )
            return url
        except S3Error as e:
            logger.error(f"生成预签名URL错误: {str(e)}")
            raise Exception(f"生成访问链接失败: {str(e)}")
    
    async def delete_file(self, bucket_name, object_key):
        """
        删除MinIO中的文件
        
        参数:
            bucket_name: 桶名称
            object_key: 对象键
            
        返回:
            删除是否成功
        """
        try:
            self.client.remove_object(
                bucket_name=bucket_name,
                object_name=object_key
            )
            return True
        except S3Error as e:
            logger.error(f"MinIO删除错误: {str(e)}")
            raise Exception(f"删除存储文件失败: {str(e)}")
```

## 四、任务处理系统实现

### 1. Celery任务定义
```python
@celery_app.task(bind=True, name="process_document")
def process_document(self, document_id: int, task_id: str, file_path: str):
    """处理文档的主任务"""
    try:
        # 获取任务和相关服务
        task_service = get_task_service()
        document_service = get_document_service()
        storage_service = get_storage_service()
        
        # 更新任务状态为运行中
        task_service.update_task_status(task_id, "RUNNING")
        task_service.update_task_start_time(task_id)
        push_task_update(task_id)  # 推送状态更新
        
        # 定义处理步骤
        steps = [
            {
                "name": "VALIDATE",
                "func": document_service.validate_document,
                "weight": 5,  # 进度权重百分比
            },
            {
                "name": "UPLOAD_TO_STORAGE",  # 步骤：上传到MinIO
                "func": storage_service.upload_file_and_update_document,
                "weight": 10,
            },
            {
                "name": "EXTRACT_TEXT",
                "func": document_service.extract_text_from_file,
                "weight": 30,
            },
            {
                "name": "PREPROCESS",
                "func": document_service.preprocess_text,
                "weight": 15,
            },
            {
                "name": "VECTORIZE",
                "func": document_service.vectorize_document,
                "weight": 30,
            },
            {
                "name": "STORE",
                "func": document_service.store_document_vectors,
                "weight": 10,
            }
        ]
        
        # 执行每个步骤
        document_data = {"file_path": file_path}
        overall_progress = 0
        
        for step in steps:
            # 更新步骤状态
            task_service.update_step_status(task_id, step["name"], "RUNNING")
            task_service.update_step_start_time(task_id, step["name"])
            push_task_update(task_id)  # 推送状态更新
            
            # 执行步骤
            try:
                step_result = step["func"](document_id, **document_data)
                document_data.update(step_result)  # 更新数据用于下一步骤
                
                # 更新步骤完成状态
                task_service.update_step_status(
                    task_id, 
                    step["name"], 
                    "COMPLETED", 
                    progress=100,
                    details={"output": str(step_result)}
                )
                task_service.update_step_complete_time(task_id, step["name"])
                
                # 更新总体进度
                overall_progress += step["weight"]
                task_service.update_task_progress(task_id, overall_progress)
                push_task_update(task_id)  # 推送状态更新
                
            except Exception as e:
                # 步骤失败处理
                logger.error(f"任务步骤 {step['name']} 失败: {str(e)}")
                task_service.update_step_status(
                    task_id, 
                    step["name"], 
                    "FAILED", 
                    error_message=str(e)
                )
                
                # 更新任务状态为失败
                task_service.update_task_status(task_id, "FAILED", error_message=str(e))
                push_task_update(task_id)  # 推送状态更新
                
                # 清理临时文件
                if os.path.exists(file_path):
                    os.remove(file_path)
                    
                return False
        
        # 更新文档状态为已处理
        document_service.update_document_processing_status(document_id, "COMPLETED")
        
        # 更新任务状态为已完成
        task_service.update_task_status(task_id, "COMPLETED", progress=100)
        task_service.update_task_complete_time(task_id)
        push_task_update(task_id)  # 推送状态更新
        
        # 清理临时文件
        if os.path.exists(file_path):
            os.remove(file_path)
            
        return True
        
    except Exception as e:
        # 任务整体异常处理
        logger.error(f"处理文档任务失败: {str(e)}")
        task_service.update_task_status(task_id, "FAILED", error_message=str(e))
        push_task_update(task_id)  # 推送状态更新
        
        # 清理临时文件
        if os.path.exists(file_path):
            os.remove(file_path)
            
        return False
```

### 2. 文档服务修改
```python
class DocumentService:
    # ... 保留其他方法 ...
    
    async def update_document_storage_info(self, document_id, bucket_name, object_key, content_type, file_size, etag):
        """更新文档的存储信息"""
        document = await self.get_document_by_id(document_id)
        if not document:
            raise ValueError(f"文档不存在: {document_id}")
            
        document.bucket_name = bucket_name
        document.object_key = object_key
        document.content_type = content_type
        document.file_size = file_size
        document.etag = etag
        document.updated_at = datetime.now()
        
        self.db.commit()
        return document
        
    async def extract_text_from_file(self, document_id, **kwargs):
        """从文件中提取文本"""
        document = await self.get_document_by_id(document_id)
        if not document:
            raise ValueError(f"文档不存在: {document_id}")
            
        temp_file_path = None
        try:
            # 确定文件路径
            file_path = kwargs.get("file_path")
            
            # 如果没有本地文件路径但有MinIO存储信息，则从MinIO下载
            if not file_path and document.object_key:
                storage_service = get_storage_service()
                temp_file_path = await storage_service.download_to_temp(
                    document.bucket_name,
                    document.object_key
                )
                file_path = temp_file_path
                
            if not file_path:
                raise ValueError(f"无法获取文档文件: {document_id}")
                
            # 根据文件类型提取文本
            file_type = document.file_type.lower()
            text = ""
            
            if file_type in ['.pdf']:
                text = self._extract_text_from_pdf(file_path)
            elif file_type in ['.docx', '.doc']:
                text = self._extract_text_from_word(file_path)
            elif file_type in ['.txt']:
                with open(file_path, 'r', encoding='utf-8') as f:
                    text = f.read()
            else:
                raise ValueError(f"不支持的文件类型: {file_type}")
                
            # 如果是临时下载的文件，清理它
            if temp_file_path and os.path.exists(temp_file_path):
                os.remove(temp_file_path)
                temp_dir = os.path.dirname(temp_file_path)
                if os.path.exists(temp_dir) and len(os.listdir(temp_dir)) == 0:
                    os.rmdir(temp_dir)
                    
            return {"extracted_text": text}
            
        except Exception as e:
            # 确保清理临时文件
            if temp_file_path and os.path.exists(temp_file_path):
                os.remove(temp_file_path)
                temp_dir = os.path.dirname(temp_file_path)
                if os.path.exists(temp_dir) and len(os.listdir(temp_dir)) == 0:
                    os.rmdir(temp_dir)
                    
            logger.error(f"文本提取失败: {str(e)}")
            raise ValueError(f"文本提取失败: {str(e)}")
    
    # ... 实现其他处理方法 ...
```

### 3. 状态更新推送函数
```python
def push_task_update(task_id: str):
    """推送任务状态更新"""
    try:
        # 获取完整任务状态
        task_service = get_task_service()
        task_data = task_service.get_task_with_details(task_id)
        
        # 异步推送到WebSocket
        asyncio.run(manager.send_update(task_id, {
            "event": "task_update",
            "data": task_data
        }))
    except Exception as e:
        logger.error(f"推送任务更新失败: {str(e)}")
```

### 4. WebSocket连接管理器
```python
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, List[WebSocket]] = {}
        self.lock = asyncio.Lock()

    async def connect(self, websocket: WebSocket, task_id: str):
        await websocket.accept()
        async with self.lock:
            if task_id not in self.active_connections:
                self.active_connections[task_id] = []
            self.active_connections[task_id].append(websocket)

    def disconnect(self, websocket: WebSocket, task_id: str):
        if task_id in self.active_connections:
            self.active_connections[task_id].remove(websocket)
            if len(self.active_connections[task_id]) == 0:
                del self.active_connections[task_id]

    async def send_update(self, task_id: str, message: dict):
        if task_id in self.active_connections:
            dead_connections = []
            for connection in self.active_connections[task_id]:
                try:
                    await connection.send_json(message)
                except Exception:
                    dead_connections.append(connection)
                    
            # 移除死连接
            for dead in dead_connections:
                self.active_connections[task_id].remove(dead)
                
            # 如果没有连接了，清理字典
            if not self.active_connections[task_id]:
                del self.active_connections[task_id]

manager = ConnectionManager()
```

## 五、前端实现

### 1. 文档上传组件保持不变

### 2. 文档下载组件（新增）
```tsx
import React, { useState } from 'react';
import { Button, message } from 'antd';
import { DownloadOutlined } from '@ant-design/icons';
import { downloadDocument } from '../api/documents';

const DocumentDownloader = ({ documentId, documentName }) => {
  const [loading, setLoading] = useState(false);
  
  const handleDownload = async () => {
    setLoading(true);
    
    try {
      const response = await downloadDocument(documentId);
      
      if (response.success && response.download_url) {
        // 创建一个隐藏的a标签并模拟点击
        const link = document.createElement('a');
        link.href = response.download_url;
        link.target = '_blank';
        link.download = response.document_name || documentName || `document-${documentId}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        message.success('文件开始下载');
      } else {
        message.error(response.message || '下载文件失败');
      }
    } catch (error) {
      message.error('下载文件失败: ' + (error.message || '未知错误'));
    } finally {
      setLoading(false);
    }
  };

  return (
    <Button 
      type="primary"
      icon={<DownloadOutlined />}
      onClick={handleDownload}
      loading={loading}
    >
      下载原文件
    </Button>
  );
};

export default DocumentDownloader;
```

### 3. 文档详情页面修改（添加下载按钮）
```tsx
import React from 'react';
import { Card, Descriptions, Button, Space } from 'antd';
import DocumentDownloader from '../components/DocumentDownloader';

const DocumentDetailPage = ({ document }) => {
  return (
    <Card 
      title={document.name}
      extra={
        <Space>
          <DocumentDownloader 
            documentId={document.id}
            documentName={document.name}
          />
          <Button type="default">编辑元数据</Button>
        </Space>
      }
    >
      <Descriptions bordered column={2}>
        <Descriptions.Item label="ID">{document.id}</Descriptions.Item>
        <Descriptions.Item label="文件类型">{document.file_type}</Descriptions.Item>
        <Descriptions.Item label="上传时间">{document.created_at}</Descriptions.Item>
        <Descriptions.Item label="处理状态">{document.processing_status}</Descriptions.Item>
        <Descriptions.Item label="文件大小">{document.file_size ? `${(document.file_size / 1024 / 1024).toFixed(2)} MB` : '未知'}</Descriptions.Item>
        <Descriptions.Item label="用户">{document.user_id}</Descriptions.Item>
        <Descriptions.Item label="元数据" span={2}>
          <pre>{JSON.stringify(document.metadata, null, 2)}</pre>
        </Descriptions.Item>
      </Descriptions>
    </Card>
  );
};

export default DocumentDetailPage;
```

### 4. API客户端扩展
```tsx
// api/documents.js
import axios from 'axios';

export const uploadDocument = async (file, metadata = {}) => {
  try {
    const formData = new FormData();
    formData.append('file', file);
    
    // 将元数据转换为JSON字符串
    if (metadata) {
      formData.append('metadata', JSON.stringify(metadata));
    }
    
    const response = await axios.post('/api/documents/upload', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    
    return response.data;
  } catch (error) {
    throw new Error(error.response?.data?.detail || '上传文档失败');
  }
};

export const downloadDocument = async (documentId) => {
  try {
    const response = await axios.get(`/api/documents/${documentId}/download`);
    return response.data;
  } catch (error) {
    throw new Error(error.response?.data?.detail || '获取下载链接失败');
  }
};

// ... 其他API方法 ...
```

## 六、配置与部署

### 1. MinIO配置
```python
# settings.py
# MinIO配置
MINIO_ENDPOINT = os.getenv("MINIO_ENDPOINT", "minio:9000")
MINIO_ACCESS_KEY = os.getenv("MINIO_ACCESS_KEY", "minioadmin")
MINIO_SECRET_KEY = os.getenv("MINIO_SECRET_KEY", "minioadmin")
MINIO_SECURE = os.getenv("MINIO_SECURE", "false").lower() == "true"
MINIO_DOCUMENT_BUCKET = os.getenv("MINIO_DOCUMENT_BUCKET", "documents")
```

### 2. Redis配置
```python
# settings.py
REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
REDIS_PORT = int(os.getenv("REDIS_PORT", 6379))
REDIS_DB = int(os.getenv("REDIS_DB", 0))
REDIS_PASSWORD = os.getenv("REDIS_PASSWORD", None)

CELERY_BROKER_URL = f"redis://{':' + REDIS_PASSWORD + '@' if REDIS_PASSWORD else ''}{REDIS_HOST}:{REDIS_PORT}/{REDIS_DB}"
CELERY_RESULT_BACKEND = CELERY_BROKER_URL
```

### 3. Celery配置
```python
# celery_config.py
from celery import Celery
from app.core.config import settings

celery_app = Celery(
    "document_processing",
    broker=settings.CELERY_BROKER_URL,
    backend=settings.CELERY_RESULT_BACKEND,
    include=["app.tasks.document_processing"]
)

celery_app.conf.update(
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    timezone="Asia/Shanghai",
    enable_utc=False,
    task_track_started=True,
    task_time_limit=3600,  # 1小时超时
    worker_max_tasks_per_child=200,
    worker_prefetch_multiplier=4
)
```

### 4. Docker部署配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  api:
    build: 
      context: .
      dockerfile: Dockerfile.api
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis
      - minio
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/dbname
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=minioadmin
      - MINIO_SECRET_KEY=minioadmin
      - MINIO_SECURE=false
    volumes:
      - ./app:/app
    restart: always

  worker:
    build:
      context: .
      dockerfile: Dockerfile.worker
    depends_on:
      - redis
      - postgres
      - minio
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/dbname
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=minioadmin
      - MINIO_SECRET_KEY=minioadmin
      - MINIO_SECURE=false
    volumes:
      - ./app:/app
    restart: always
    command: celery -A app.core.celery_app worker --loglevel=info

  minio:
    image: minio/minio
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      - MINIO_ROOT_USER=minioadmin
      - MINIO_ROOT_PASSWORD=minioadmin
    volumes:
      - minio_data:/data
    command: server --console-address ":9001" /data
    restart: always

  redis:
    image: redis:7.0-alpine
    ports:
      - "6379:6379"
    restart: always
    volumes:
      - redis_data:/data

  postgres:
    image: postgres:15-alpine
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=dbname
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: always

volumes:
  redis_data:
  postgres_data:
  minio_data:
```

## 七、实施清单

实现清单：
1. 创建数据库表结构：
   - Tasks和Task_Details表
   - 修改Documents表，添加MinIO对象存储相关字段
2. 实现MinIO存储服务：
   - 创建StorageService类
   - 实现文件上传、下载和预签名URL生成功能
3. 实现连接管理器：
   - 创建ConnectionManager类管理WebSocket连接
   - 实现WebSocket推送功能
4. 创建后端API端点：
   - 文档上传API
   - 文档下载API
   - 任务状态查询API
   - WebSocket任务监控端点
5. 实现Celery任务处理流程：
   - 文件验证
   - 上传到MinIO
   - 文本提取
   - 文本预处理
   - 向量化处理
   - 存储向量
6. 修改文档服务：
   - 添加MinIO支持
   - 实现从MinIO下载处理文件
   - 更新存储信息方法
7. 实现前端组件：
   - 文档下载组件
   - 更新文档详情页面
   - 扩展API客户端
8. 配置与部署：
   - 添加MinIO配置
   - 配置Redis和Celery
   - 设置Docker部署环境
9. 实现数据迁移：
   - 创建数据库迁移脚本
   - 将现有文件迁移到MinIO
10. 测试与监控：
   - 测试完整流程
   - 添加错误处理和重试机制
   - 实现任务监控和统计 
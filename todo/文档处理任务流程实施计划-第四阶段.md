# 文档处理任务流程实施计划 - 第四阶段

## 第四阶段：集成测试与部署

### 一、单元测试实现

#### 1. 服务层测试

**位置**: `notebook-backend/tests/services/`

```python
# test_task_detail_service.py
import pytest
from datetime import datetime
from app.services.task_detail_service import TaskDetailService
from app.models.task import TaskDetail, TaskStatus

def test_create_task_detail(db_session):
    # 准备测试数据
    task_id = "test-task-id"
    step_name = "测试步骤"
    step_order = 1
    
    # 创建服务实例
    service = TaskDetailService(db_session)
    
    # 执行测试方法
    task_detail = service.create_task_detail(task_id, step_name, step_order)
    
    # 断言结果
    assert task_detail.id is not None
    assert task_detail.task_id == task_id
    assert task_detail.step_name == step_name
    assert task_detail.step_order == step_order
    assert task_detail.status == TaskStatus.PENDING
    assert task_detail.progress == 0

def test_update_task_detail(db_session):
    # 准备测试数据
    task_detail = TaskDetail(
        task_id="test-task-id",
        step_name="测试步骤",
        step_order=1,
        status=TaskStatus.PENDING,
        progress=0
    )
    db_session.add(task_detail)
    db_session.commit()
    
    # 创建服务实例
    service = TaskDetailService(db_session)
    
    # 执行测试方法
    updated_detail = service.update_task_detail(
        task_detail.id,
        status=TaskStatus.RUNNING,
        progress=50,
        details={"test_key": "test_value"},
        error_message=None
    )
    
    # 断言结果
    assert updated_detail.status == TaskStatus.RUNNING
    assert updated_detail.progress == 50
    assert updated_detail.details == {"test_key": "test_value"}
    assert updated_detail.started_at is not None

def test_get_task_details_by_task_id(db_session):
    # 准备测试数据
    task_id = "test-task-id"
    for i in range(3):
        task_detail = TaskDetail(
            task_id=task_id,
            step_name=f"步骤 {i+1}",
            step_order=i+1,
            status=TaskStatus.PENDING,
            progress=0
        )
        db_session.add(task_detail)
    db_session.commit()
    
    # 创建服务实例
    service = TaskDetailService(db_session)
    
    # 执行测试方法
    details = service.get_task_details_by_task_id(task_id)
    
    # 断言结果
    assert len(details) == 3
    assert details[0].step_order == 1
    assert details[1].step_order == 2
    assert details[2].step_order == 3
```

```python
# test_storage_service.py
import os
import tempfile
import pytest
from unittest.mock import MagicMock, patch
from app.services.storage_service import StorageService
from fastapi import UploadFile

@pytest.fixture
def storage_service():
    with patch('app.services.storage_service.minio.Minio') as mock_minio:
        service = StorageService()
        service.minio_client = mock_minio.return_value
        yield service

@pytest.mark.asyncio
async def test_save_upload_file_temp():
    # 模拟上传文件
    content = b"test file content"
    upload_file = MagicMock(spec=UploadFile)
    upload_file.filename = "test.txt"
    upload_file.read.return_value = content
    
    # 创建服务实例
    service = StorageService()
    
    # 执行测试方法
    temp_file_path = await service.save_upload_file_temp(upload_file)
    
    try:
        # 断言结果
        assert os.path.exists(temp_file_path)
        with open(temp_file_path, "rb") as f:
            assert f.read() == content
    finally:
        # 清理临时文件
        if os.path.exists(temp_file_path):
            os.remove(temp_file_path)

def test_upload_file_to_minio(storage_service):
    # 准备测试数据
    with tempfile.NamedTemporaryFile(delete=False) as temp_file:
        temp_file.write(b"test content")
        file_path = temp_file.name
    
    bucket_name = "test-bucket"
    object_key = "test/object.txt"
    
    # 设置mock行为
    storage_service.minio_client.bucket_exists.return_value = False
    
    # 执行测试方法
    result = storage_service.upload_file_to_minio(file_path, bucket_name, object_key)
    
    # 断言结果
    assert result is True
    storage_service.minio_client.bucket_exists.assert_called_once_with(bucket_name)
    storage_service.minio_client.make_bucket.assert_called_once_with(bucket_name)
    storage_service.minio_client.fput_object.assert_called_once_with(
        bucket_name=bucket_name,
        object_name=object_key,
        file_path=file_path
    )
    
    # 清理临时文件
    os.remove(file_path)
```

#### 2. API端点测试

**位置**: `notebook-backend/tests/api/`

```python
# test_documents_api.py
import pytest
from fastapi.testclient import TestClient
from unittest.mock import patch, MagicMock
from app.main import app

@pytest.fixture
def client():
    return TestClient(app)

@pytest.fixture
def mock_current_user():
    with patch("app.auth.auth.get_current_user") as mock:
        mock.return_value = MagicMock(id=1, username="testuser")
        yield mock

def test_upload_document(client, mock_current_user):
    # 模拟文件上传
    with patch("app.api.endpoints.documents.DocumentService") as mock_doc_service, \
         patch("app.api.endpoints.documents.TaskService") as mock_task_service, \
         patch("app.api.endpoints.documents.StorageService") as mock_storage_service, \
         patch("app.api.endpoints.documents.process_document") as mock_process:
        
        # 设置mock返回值
        mock_storage_service.return_value.save_upload_file_temp.return_value = "/tmp/test.txt"
        mock_doc_service.return_value.create_document.return_value = MagicMock(id="doc-id", name="test.txt")
        mock_task_service.return_value.create_task.return_value = MagicMock(id="task-id")
        
        # 执行测试请求
        with open("tests/fixtures/test.txt", "rb") as f:
            response = client.post(
                "/api/documents/upload",
                files={"file": ("test.txt", f, "text/plain")},
                headers={"Authorization": "Bearer test_token"}
            )
        
        # 断言结果
        assert response.status_code == 200
        assert response.json()["id"] == "doc-id"
        assert response.json()["name"] == "test.txt"
        
        # 验证mock调用
        mock_storage_service.return_value.save_upload_file_temp.assert_called_once()
        mock_doc_service.return_value.create_document.assert_called_once()
        mock_task_service.return_value.create_task.assert_called_once()
        mock_process.delay.assert_called_once()
```

```python
# test_tasks_api.py
import pytest
from fastapi.testclient import TestClient
from unittest.mock import patch, MagicMock
from app.main import app

@pytest.fixture
def client():
    return TestClient(app)

@pytest.fixture
def mock_current_user():
    with patch("app.auth.auth.get_current_user") as mock:
        mock.return_value = MagicMock(id=1, username="testuser")
        yield mock

def test_get_task_details(client, mock_current_user):
    # 准备测试数据
    task_id = "test-task-id"
    
    # 模拟服务返回值
    with patch("app.api.endpoints.tasks.TaskService") as mock_task_service, \
         patch("app.api.endpoints.tasks.TaskDetailService") as mock_detail_service:
        
        mock_task = MagicMock(id=task_id, created_by=1)
        mock_task_service.return_value.get_task_by_id.return_value = mock_task
        
        mock_details = [
            MagicMock(id=1, step_name="步骤1", step_order=1, status="COMPLETED", progress=100),
            MagicMock(id=2, step_name="步骤2", step_order=2, status="RUNNING", progress=50)
        ]
        mock_detail_service.return_value.get_task_details_by_task_id.return_value = mock_details
        
        # 执行测试请求
        response = client.get(
            f"/api/tasks/{task_id}/details",
            headers={"Authorization": "Bearer test_token"}
        )
        
        # 断言结果
        assert response.status_code == 200
        assert response.json()["task_id"] == task_id
        assert len(response.json()["task_details"]) == 2
        
        # 验证mock调用
        mock_task_service.return_value.get_task_by_id.assert_called_once_with(task_id)
        mock_detail_service.return_value.get_task_details_by_task_id.assert_called_once_with(task_id)
```

### 二、集成测试实现

#### 1. 端到端测试

**位置**: `notebook-backend/tests/integration/`

```python
# test_document_processing.py
import pytest
import os
import tempfile
import time
from sqlalchemy.orm import Session
from app.database import get_db
from app.services.document_service import DocumentService
from app.services.task_service import TaskService
from app.services.task_detail_service import TaskDetailService
from app.celery_tasks.document_processing import process_document

def create_test_document(db: Session):
    """创建测试文档"""
    document_service = DocumentService(db)
    document = document_service.create_document({
        "name": "test_document.txt",
        "file_type": "txt",
        "user_id": 1,
        "processing_status": "PENDING"
    })
    return document

def create_test_task(db: Session, document_id: str):
    """创建测试任务"""
    task_service = TaskService(db)
    task = task_service.create_task(
        name="测试任务",
        task_type="DOCUMENT_PROCESSING",
        created_by=1,
        document_id=document_id,
        description="测试文档处理流程",
        metadata={}
    )
    return task

@pytest.mark.integration
def test_full_document_processing():
    """测试完整的文档处理流程"""
    # 创建临时测试文件
    with tempfile.NamedTemporaryFile(delete=False, suffix=".txt") as temp_file:
        temp_file.write(b"This is a test document for processing.")
        file_path = temp_file.name
    
    try:
        # 获取数据库会话
        db = next(get_db())
        
        # 创建测试文档和任务
        document = create_test_document(db)
        task = create_test_task(db, document.id)
        
        # 执行文档处理任务
        process_document(document.id, task.id, file_path)
        
        # 查询任务详情
        task_service = TaskService(db)
        task_detail_service = TaskDetailService(db)
        
        # 等待任务完成
        max_wait = 30  # 最大等待30秒
        start_time = time.time()
        while time.time() - start_time < max_wait:
            updated_task = task_service.get_task_by_id(task.id)
            if updated_task.status in ["COMPLETED", "FAILED"]:
                break
            time.sleep(1)
        
        # 获取最终任务状态
        final_task = task_service.get_task_by_id(task.id)
        task_details = task_detail_service.get_task_details_by_task_id(task.id)
        
        # 断言任务状态
        assert final_task.status == "COMPLETED"
        assert final_task.progress == 100
        
        # 断言任务详情
        assert len(task_details) > 0
        for detail in task_details:
            assert detail.status == "COMPLETED"
            assert detail.progress == 100
        
        # 断言文档状态
        document_service = DocumentService(db)
        updated_document = document_service.get_document_by_id(document.id)
        assert updated_document.processing_status == "AVAILABLE"
        
    finally:
        # 清理测试文件
        if os.path.exists(file_path):
            os.remove(file_path)
```

#### 2. 前端集成测试

**位置**: `notebook-frontend/cypress/integration/`

```javascript
// document_upload_spec.js
describe('文档上传流程', () => {
  beforeEach(() => {
    // 登录并导航到上传页面
    cy.login('testuser', 'password');
    cy.visit('/documents/upload');
  });

  it('能够成功上传文档并显示处理进度', () => {
    // 模拟API响应
    cy.intercept('POST', '/api/documents/upload', {
      statusCode: 200,
      body: {
        id: 'doc-123',
        name: 'test.txt',
        task_id: 'task-123'
      }
    }).as('uploadDocument');

    cy.intercept('GET', '/api/tasks/task-123/details', {
      statusCode: 200,
      body: {
        task_id: 'task-123',
        task_details: [
          { id: 1, step_name: '文件验证', step_order: 1, status: 'COMPLETED', progress: 100 },
          { id: 2, step_name: '文本提取', step_order: 2, status: 'RUNNING', progress: 50 },
          { id: 3, step_name: '文本分块', step_order: 3, status: 'PENDING', progress: 0 },
          { id: 4, step_name: '生成向量', step_order: 4, status: 'PENDING', progress: 0 },
          { id: 5, step_name: '向量存储', step_order: 5, status: 'PENDING', progress: 0 }
        ]
      }
    }).as('getTaskDetails');

    // 选择文件
    cy.get('input[type=file]').attachFile('test.txt');
    
    // 点击上传按钮
    cy.contains('button', '开始上传').click();
    
    // 等待上传请求完成
    cy.wait('@uploadDocument');
    
    // 验证上传成功界面显示
    cy.contains('文件上传成功').should('be.visible');
    
    // 等待任务详情请求完成
    cy.wait('@getTaskDetails');
    
    // 验证进度条显示
    cy.contains('总体进度').should('be.visible');
    cy.contains('步骤').should('have.length', 5);
    
    // 验证当前步骤状态
    cy.contains('文件验证').parent().contains('已完成').should('be.visible');
    cy.contains('文本提取').parent().contains('处理中').should('be.visible');
  });

  it('处理上传失败场景', () => {
    // 模拟上传失败
    cy.intercept('POST', '/api/documents/upload', {
      statusCode: 500,
      body: {
        detail: '文件上传失败'
      }
    }).as('uploadFailed');

    // 选择文件
    cy.get('input[type=file]').attachFile('test.txt');
    
    // 点击上传按钮
    cy.contains('button', '开始上传').click();
    
    // 等待上传请求完成
    cy.wait('@uploadFailed');
    
    // 验证错误消息
    cy.contains('文件上传失败').should('be.visible');
  });
});
```

### 三、部署准备

#### 1. Docker容器化

**位置**: `notebook-backend/Dockerfile`

```dockerfile
FROM python:3.10-slim

WORKDIR /app

# 设置环境变量
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=off \
    PIP_DISABLE_PIP_VERSION_CHECK=on

# 安装系统依赖
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# 复制项目文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 暴露应用端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**位置**: `notebook-frontend/Dockerfile`

```dockerfile
# 构建阶段
FROM node:16-alpine as build

WORKDIR /app

# 复制package.json和package-lock.json
COPY package*.json ./

# 安装依赖
RUN npm ci

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 部署阶段
FROM nginx:alpine

# 复制构建产物到Nginx目录
COPY --from=build /app/build /usr/share/nginx/html

# 复制Nginx配置
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 暴露端口
EXPOSE 80

# 启动Nginx
CMD ["nginx", "-g", "daemon off;"]
```

#### 2. Docker Compose配置

**位置**: `docker-compose.yml`

```yaml
version: '3.8'

services:
  backend:
    build: ./notebook-backend
    container_name: notebook-backend
    restart: always
    depends_on:
      - postgres
      - redis
      - minio
      - qdrant
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_HOST=postgres
      - POSTGRES_PORT=5432
      - POSTGRES_DB=notebook
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=minioadmin
      - MINIO_SECRET_KEY=minioadmin
      - MINIO_USE_SSL=false
      - QDRANT_URL=http://qdrant:6333
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/0
      - SECRET_KEY=${SECRET_KEY}
    ports:
      - "8000:8000"
    volumes:
      - ./notebook-backend:/app
    networks:
      - notebook-network

  celery-worker:
    build: ./notebook-backend
    container_name: notebook-celery-worker
    restart: always
    depends_on:
      - backend
      - redis
    command: celery -A app.celery_app worker --loglevel=info
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_HOST=postgres
      - POSTGRES_PORT=5432
      - POSTGRES_DB=notebook
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=minioadmin
      - MINIO_SECRET_KEY=minioadmin
      - MINIO_USE_SSL=false
      - QDRANT_URL=http://qdrant:6333
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/0
    volumes:
      - ./notebook-backend:/app
    networks:
      - notebook-network

  frontend:
    build: ./notebook-frontend
    container_name: notebook-frontend
    restart: always
    depends_on:
      - backend
    ports:
      - "80:80"
    environment:
      - REACT_APP_API_URL=http://localhost:8000/api
      - REACT_APP_WS_URL=ws://localhost:8000
    networks:
      - notebook-network

  postgres:
    image: postgres:14-alpine
    container_name: notebook-postgres
    restart: always
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=notebook
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - notebook-network

  redis:
    image: redis:alpine
    container_name: notebook-redis
    restart: always
    ports:
      - "6379:6379"
    networks:
      - notebook-network

  minio:
    image: minio/minio
    container_name: notebook-minio
    restart: always
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      - MINIO_ROOT_USER=minioadmin
      - MINIO_ROOT_PASSWORD=minioadmin
    command: server /data --console-address ":9001"
    volumes:
      - minio-data:/data
    networks:
      - notebook-network

  qdrant:
    image: qdrant/qdrant
    container_name: notebook-qdrant
    restart: always
    ports:
      - "6333:6333"
      - "6334:6334"
    volumes:
      - qdrant-data:/qdrant/storage
    networks:
      - notebook-network

networks:
  notebook-network:
    driver: bridge

volumes:
  postgres-data:
  minio-data:
  qdrant-data:
```

### 四、部署脚本

**位置**: `deploy.sh`

```bash
#!/bin/bash

# 定义颜色
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# 显示帮助信息
function show_help {
  echo "文档处理系统部署脚本"
  echo ""
  echo "用法: $0 [选项]"
  echo "选项:"
  echo "  -h, --help      显示帮助信息"
  echo "  -e, --env ENV   指定环境 (dev|test|prod), 默认为dev"
  echo "  -b, --build     强制重新构建镜像"
  echo ""
}

# 设置默认值
ENV="dev"
REBUILD=false

# 解析命令行参数
while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      show_help
      exit 0
      ;;
    -e|--env)
      ENV="$2"
      shift 2
      ;;
    -b|--build)
      REBUILD=true
      shift
      ;;
    *)
      echo -e "${RED}未知参数: $1${NC}"
      show_help
      exit 1
      ;;
  esac
done

# 验证环境参数
if [[ "$ENV" != "dev" && "$ENV" != "test" && "$ENV" != "prod" ]]; then
  echo -e "${RED}错误: 环境必须是 dev, test 或 prod${NC}"
  exit 1
fi

# 加载环境变量
echo -e "${GREEN}加载 $ENV 环境的配置...${NC}"
if [ -f ".env.$ENV" ]; then
  set -a
  source .env.$ENV
  set +a
else
  echo -e "${RED}错误: 找不到环境文件 .env.$ENV${NC}"
  exit 1
fi

# 创建目录
mkdir -p logs

# 设置构建参数
BUILD_ARGS=""
if [ "$REBUILD" = true ]; then
  BUILD_ARGS="--build --no-cache"
fi

# 开始部署
echo -e "${GREEN}开始部署文档处理系统 ($ENV 环境)...${NC}"

# 停止现有容器
echo -e "${GREEN}停止现有容器...${NC}"
docker-compose down

# 构建和启动容器
echo -e "${GREEN}构建和启动容器...${NC}"
docker-compose -f docker-compose.yml -f docker-compose.$ENV.yml up -d $BUILD_ARGS

# 执行数据库迁移
echo -e "${GREEN}执行数据库迁移...${NC}"
docker-compose exec backend alembic upgrade head

# 检查服务状态
echo -e "${GREEN}检查服务状态...${NC}"
docker-compose ps

echo -e "${GREEN}部署完成!${NC}"
```

### 五、第四阶段实施步骤

1. 实现测试套件
   1.1. 编写服务层单元测试
   1.2. 编写API端点测试
   1.3. 编写集成测试
   1.4. 编写前端组件测试

2. 准备容器化部署
   2.1. 创建Docker镜像文件
   2.2. 创建Docker Compose配置
   2.3. 创建部署脚本

3. 监控和日志配置
   3.1. 配置日志收集
   3.2. 设置监控告警
   3.3. 配置性能监控

4. 部署文档准备
   4.1. 编写部署指南
   4.2. 编写故障排除指南
   4.3. 编写用户使用手册

### 六、测试与验证

1. 自动化测试执行
   - 运行单元测试 `pytest tests/services/`
   - 运行API测试 `pytest tests/api/`
   - 运行集成测试 `pytest tests/integration/`
   - 运行前端测试 `npm test`
   - 运行端到端测试 `npx cypress run`

2. 手动验证
   - 在不同环境运行部署脚本
   - 验证各组件是否正常工作
   - 验证文档处理流程是否完整

3. 性能测试
   - 测试文件上传性能
   - 测试文档处理速度
   - 测试系统在高负载下的表现 
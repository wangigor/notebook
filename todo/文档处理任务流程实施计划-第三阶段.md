# 文档处理任务流程实施计划 - 第三阶段

## 第三阶段：API路由与前端组件实现

### 一、API路由实现

#### 1. 任务API路由

**位置**: `notebook-backend/app/api/endpoints/tasks.py`

```python
from fastapi import APIRouter, Depends, HTTPException, Query, WebSocket
from sqlalchemy.orm import Session
from typing import List, Optional
from app.database import get_db
from app.models.task import TaskCreate, TaskStatusResponse, TaskDetail, TaskList
from app.services.task_service import TaskService
from app.services.task_detail_service import TaskDetailService
from app.websockets.task_manager import task_websocket_endpoint, push_task_update
from app.auth.auth import get_current_user
from app.models.user import User

router = APIRouter()

@router.get("", response_model=TaskList)
async def get_tasks(
    page: int = Query(1, gt=0),
    limit: int = Query(10, gt=0),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取任务列表"""
    task_service = TaskService(db)
    tasks, total = task_service.get_tasks(
        created_by=current_user.id,
        page=page,
        limit=limit
    )
    return TaskList(tasks=tasks, total=total)

@router.get("/{task_id}", response_model=TaskStatusResponse)
async def get_task(
    task_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取任务详情"""
    task_service = TaskService(db)
    task = task_service.get_task_by_id(task_id)
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    # 验证用户权限
    if task.created_by != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view this task")
    
    return task

@router.get("/{task_id}/details")
async def get_task_details(
    task_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取任务步骤详情"""
    task_service = TaskService(db)
    task_detail_service = TaskDetailService(db)
    
    task = task_service.get_task_by_id(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    # 验证用户权限
    if task.created_by != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view this task")
    
    task_details = task_detail_service.get_task_details_by_task_id(task_id)
    
    return {
        "task_id": task_id,
        "task_details": task_details
    }

@router.post("/{task_id}/cancel", response_model=TaskStatusResponse)
async def cancel_task(
    task_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """取消任务"""
    task_service = TaskService(db)
    
    task = task_service.get_task_by_id(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    # 验证用户权限
    if task.created_by != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to cancel this task")
    
    task = task_service.cancel_task(task_id)
    
    # 推送更新到WebSocket
    await push_task_update(task_id, task_service)
    
    return task
```

#### 2. 文档API路由

**位置**: `notebook-backend/app/api/endpoints/documents.py`

```python
from fastapi import APIRouter, Depends, File, UploadFile, Form, HTTPException, Query
from sqlalchemy.orm import Session
from typing import Optional, Dict, Any
import json
import uuid
from datetime import datetime
import os

from app.database import get_db
from app.models.document import DocumentCreate, DocumentResponse, DocumentList
from app.models.task import TaskStatus
from app.services.document_service import DocumentService
from app.services.task_service import TaskService
from app.services.storage_service import StorageService
from app.celery_tasks.document_processing import process_document
from app.auth.auth import get_current_user
from app.models.user import User

router = APIRouter()

@router.post("/upload", response_model=DocumentResponse)
async def upload_document(
    file: UploadFile = File(...),
    metadata: Optional[str] = Form(None),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """上传文档"""
    # 初始化服务
    document_service = DocumentService(db)
    task_service = TaskService(db)
    storage_service = StorageService()
    
    # 处理元数据
    doc_metadata = {}
    if metadata:
        try:
            doc_metadata = json.loads(metadata)
        except Exception as e:
            raise HTTPException(status_code=400, detail=f"Invalid metadata: {str(e)}")
    
    try:
        # 保存文件到临时目录
        temp_file_path = await storage_service.save_upload_file_temp(file)
        
        # 生成唯一文件名
        filename = file.filename or "unnamed_file"
        file_extension = os.path.splitext(filename)[1].lower() if filename else ""
        object_key = f"{current_user.id}/{uuid.uuid4()}/{filename}"
        
        # 创建文档记录（状态为处理中）
        document = document_service.create_document(
            DocumentCreate(
                name=filename,
                file_type=file_extension.lstrip(".") or file.content_type,
                doc_metadata=doc_metadata,
                user_id=current_user.id,
                processing_status="PROCESSING"
            )
        )
        
        # 创建任务记录
        task = task_service.create_task(
            name=f"处理文档: {filename}",
            task_type="DOCUMENT_PROCESSING",
            description=f"从文件 {filename} 中提取文本并生成向量",
            created_by=current_user.id,
            document_id=document.id,
            metadata={
                "filename": filename,
                "content_type": file.content_type,
                "upload_time": datetime.utcnow().isoformat(),
                "temp_file_path": temp_file_path,
                "object_key": object_key
            }
        )
        
        # 启动Celery任务
        process_document.delay(document.id, task.id, temp_file_path)
        
        # 将任务ID添加到文档记录
        document = document_service.update_document(document.id, {"task_id": task.id})
        
        return document
        
    except Exception as e:
        # 出现异常时清理资源
        raise HTTPException(status_code=500, detail=f"Failed to upload document: {str(e)}")

@router.get("", response_model=DocumentList)
async def get_documents(
    page: int = Query(1, gt=0),
    limit: int = Query(10, gt=0),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取文档列表"""
    document_service = DocumentService(db)
    documents, total = document_service.get_documents(
        user_id=current_user.id,
        page=page,
        limit=limit
    )
    return DocumentList(documents=documents, total=total)

@router.get("/{document_id}", response_model=DocumentResponse)
async def get_document(
    document_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取文档详情"""
    document_service = DocumentService(db)
    document = document_service.get_document_by_id(document_id)
    
    if not document:
        raise HTTPException(status_code=404, detail="Document not found")
    
    # 验证用户权限
    if document.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view this document")
    
    return document
```

### 二、前端组件实现

#### 1. 文件上传组件

**位置**: `notebook-frontend/src/components/DocumentUpload/FileUpload.jsx`

```jsx
import React, { useState } from 'react';
import { Upload, Button, message, Progress } from 'antd';
import { UploadOutlined } from '@ant-design/icons';
import { uploadDocument } from '@/api/documents';

const FileUpload = ({ onUploadSuccess }) => {
  const [uploading, setUploading] = useState(false);
  const [fileList, setFileList] = useState([]);
  const [progress, setProgress] = useState(0);

  const handleUpload = async () => {
    const formData = new FormData();
    fileList.forEach(file => {
      formData.append('file', file);
    });

    setUploading(true);
    setProgress(0);

    try {
      // 调用上传API
      const response = await uploadDocument(formData, (progressEvent) => {
        const percentCompleted = Math.round(
          (progressEvent.loaded * 100) / progressEvent.total
        );
        setProgress(percentCompleted);
      });

      setFileList([]);
      setProgress(100);
      message.success('文件上传成功');
      
      // 触发父组件的成功回调
      if (onUploadSuccess) {
        onUploadSuccess(response.data);
      }
    } catch (error) {
      message.error('文件上传失败');
      console.error('上传错误:', error);
    } finally {
      setUploading(false);
    }
  };

  const props = {
    onRemove: file => {
      setFileList(fileList.filter(item => item.uid !== file.uid));
    },
    beforeUpload: file => {
      setFileList([...fileList, file]);
      return false;
    },
    fileList,
  };

  return (
    <div className="upload-container">
      <Upload {...props}>
        <Button icon={<UploadOutlined />}>选择文件</Button>
      </Upload>
      
      {fileList.length > 0 && (
        <>
          <Button
            type="primary"
            onClick={handleUpload}
            disabled={fileList.length === 0 || uploading}
            loading={uploading}
            style={{ marginTop: 16 }}
          >
            {uploading ? '上传中...' : '开始上传'}
          </Button>
          
          {uploading && <Progress percent={progress} />}
        </>
      )}
    </div>
  );
};

export default FileUpload;
```

#### 2. 任务进度监控组件

**位置**: `notebook-frontend/src/components/TaskMonitor/TaskProgressMonitor.jsx`

```jsx
import React, { useEffect, useState } from 'react';
import { Card, Progress, Steps, Tag, Typography, Alert } from 'antd';
import { CheckCircleOutlined, CloseCircleOutlined, LoadingOutlined } from '@ant-design/icons';
import { getTaskDetails } from '@/api/tasks';
import useWebSocket from '@/hooks/useWebSocket';

const { Step } = Steps;
const { Text, Title } = Typography;

const TaskProgressMonitor = ({ taskId }) => {
  const [taskDetails, setTaskDetails] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [overallProgress, setOverallProgress] = useState(0);
  const [currentStep, setCurrentStep] = useState(0);

  // 使用WebSocket监听任务更新
  const { lastMessage } = useWebSocket(
    `${process.env.REACT_APP_WS_URL}/ws/tasks/${taskId}`
  );

  // 初始加载任务详情
  useEffect(() => {
    const fetchTaskDetails = async () => {
      try {
        setLoading(true);
        const response = await getTaskDetails(taskId);
        setTaskDetails(response.data.task_details || []);
        
        // 计算总体进度和当前步骤
        calculateProgress(response.data.task_details);
        
        setLoading(false);
      } catch (err) {
        setError('加载任务详情失败');
        setLoading(false);
        console.error('获取任务详情错误:', err);
      }
    };

    if (taskId) {
      fetchTaskDetails();
    }
  }, [taskId]);

  // 监听WebSocket消息
  useEffect(() => {
    if (lastMessage) {
      try {
        const data = JSON.parse(lastMessage.data);
        if (data.task_id === taskId) {
          // 更新任务详情
          setTaskDetails(data.task_details || []);
          
          // 计算总体进度和当前步骤
          calculateProgress(data.task_details);
        }
      } catch (err) {
        console.error('解析WebSocket消息错误:', err);
      }
    }
  }, [lastMessage, taskId]);

  // 计算总体进度和当前步骤
  const calculateProgress = (details) => {
    if (!details || details.length === 0) return;
    
    // 计算总体进度
    const totalProgress = details.reduce((sum, item) => sum + (item.progress || 0), 0) / details.length;
    setOverallProgress(Math.round(totalProgress));
    
    // 确定当前步骤
    const runningStepIndex = details.findIndex(item => item.status === 'RUNNING');
    if (runningStepIndex >= 0) {
      setCurrentStep(runningStepIndex);
    } else {
      // 如果没有正在运行的步骤，则查找最后一个已完成的步骤
      const lastCompletedIndex = details
        .map((item, index) => ({ status: item.status, index }))
        .filter(item => item.status === 'COMPLETED')
        .map(item => item.index)
        .pop();
        
      if (lastCompletedIndex !== undefined) {
        setCurrentStep(lastCompletedIndex + 1);
      }
    }
  };

  // 获取步骤状态图标
  const getStepIcon = (status) => {
    switch (status) {
      case 'COMPLETED':
        return <CheckCircleOutlined style={{ color: '#52c41a' }} />;
      case 'FAILED':
        return <CloseCircleOutlined style={{ color: '#f5222d' }} />;
      case 'RUNNING':
        return <LoadingOutlined />;
      default:
        return null;
    }
  };

  // 获取步骤状态标签
  const getStatusTag = (status) => {
    switch (status) {
      case 'PENDING':
        return <Tag color="default">等待中</Tag>;
      case 'RUNNING':
        return <Tag color="processing">处理中</Tag>;
      case 'COMPLETED':
        return <Tag color="success">已完成</Tag>;
      case 'FAILED':
        return <Tag color="error">失败</Tag>;
      default:
        return <Tag>{status}</Tag>;
    }
  };

  if (loading) return <div>加载任务进度...</div>;
  if (error) return <Alert type="error" message={error} />;

  return (
    <Card title="文档处理进度" bordered={false}>
      <div style={{ marginBottom: 20 }}>
        <Title level={5}>总体进度</Title>
        <Progress percent={overallProgress} status={overallProgress === 100 ? 'success' : 'active'} />
      </div>
      
      <Steps current={currentStep} direction="vertical">
        {taskDetails.map((step, index) => (
          <Step
            key={index}
            title={step.step_name}
            description={
              <div>
                {getStatusTag(step.status)}
                {step.status === 'RUNNING' && (
                  <Progress percent={step.progress} size="small" style={{ marginTop: 8 }} />
                )}
                {step.error_message && (
                  <Text type="danger" style={{ display: 'block', marginTop: 8 }}>
                    错误: {step.error_message}
                  </Text>
                )}
              </div>
            }
            icon={getStepIcon(step.status)}
          />
        ))}
      </Steps>
    </Card>
  );
};

export default TaskProgressMonitor;
```

#### 3. WebSocket钩子

**位置**: `notebook-frontend/src/hooks/useWebSocket.js`

```javascript
import { useEffect, useState, useRef } from 'react';

const useWebSocket = (url) => {
  const [isConnected, setIsConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState(null);
  const [error, setError] = useState(null);
  const webSocketRef = useRef(null);

  useEffect(() => {
    // 创建WebSocket连接
    const socket = new WebSocket(url);
    webSocketRef.current = socket;

    // 连接事件处理
    socket.onopen = () => {
      setIsConnected(true);
      setError(null);
    };

    // 消息接收处理
    socket.onmessage = (event) => {
      setLastMessage(event);
    };

    // 错误处理
    socket.onerror = (event) => {
      setError('WebSocket连接错误');
      console.error('WebSocket错误:', event);
    };

    // 连接关闭处理
    socket.onclose = () => {
      setIsConnected(false);
    };

    // 清理函数
    return () => {
      socket.close();
    };
  }, [url]);

  // 发送消息方法
  const sendMessage = (data) => {
    if (webSocketRef.current && isConnected) {
      webSocketRef.current.send(typeof data === 'string' ? data : JSON.stringify(data));
    } else {
      setError('WebSocket未连接，无法发送消息');
    }
  };

  return { isConnected, lastMessage, error, sendMessage };
};

export default useWebSocket;
```

#### 4. API服务

**位置**: `notebook-frontend/src/api/documents.js`

```javascript
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

// 上传文档
export const uploadDocument = (formData, onProgress) => {
  return axios.post(`${API_URL}/documents/upload`, formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
    onUploadProgress: onProgress,
  });
};

// 获取文档列表
export const getDocuments = (page = 1, limit = 10) => {
  return axios.get(`${API_URL}/documents`, {
    params: { page, limit },
  });
};

// 获取文档详情
export const getDocumentById = (documentId) => {
  return axios.get(`${API_URL}/documents/${documentId}`);
};
```

**位置**: `notebook-frontend/src/api/tasks.js`

```javascript
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

// 获取任务列表
export const getTasks = (page = 1, limit = 10) => {
  return axios.get(`${API_URL}/tasks`, {
    params: { page, limit },
  });
};

// 获取任务详情
export const getTaskById = (taskId) => {
  return axios.get(`${API_URL}/tasks/${taskId}`);
};

// 获取任务步骤详情
export const getTaskDetails = (taskId) => {
  return axios.get(`${API_URL}/tasks/${taskId}/details`);
};

// 取消任务
export const cancelTask = (taskId) => {
  return axios.post(`${API_URL}/tasks/${taskId}/cancel`);
};
```

#### 5. 文档上传页面

**位置**: `notebook-frontend/src/pages/Documents/Upload.jsx`

```jsx
import React, { useState } from 'react';
import { Card, message, Result, Button } from 'antd';
import { useNavigate } from 'react-router-dom';
import FileUpload from '@/components/DocumentUpload/FileUpload';
import TaskProgressMonitor from '@/components/TaskMonitor/TaskProgressMonitor';

const DocumentUploadPage = () => {
  const [uploadedTask, setUploadedTask] = useState(null);
  const navigate = useNavigate();

  const handleUploadSuccess = (data) => {
    setUploadedTask(data);
    message.success('文件已成功上传，正在处理中');
  };

  const handleViewDocuments = () => {
    navigate('/documents');
  };

  return (
    <div className="document-upload-page">
      <Card title="上传文档" bordered={false}>
        {!uploadedTask ? (
          <FileUpload onUploadSuccess={handleUploadSuccess} />
        ) : (
          <div>
            <Result
              status="success"
              title="文件上传成功!"
              subTitle="文件正在处理中，请等待处理完成。"
              extra={[
                <Button type="primary" key="documents" onClick={handleViewDocuments}>
                  查看所有文档
                </Button>,
              ]}
            />
            <TaskProgressMonitor taskId={uploadedTask.task_id} />
          </div>
        )}
      </Card>
    </div>
  );
};

export default DocumentUploadPage;
```

### 三、应用集成

#### 1. 前端路由配置

**位置**: `notebook-frontend/src/router/index.js`

```javascript
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import MainLayout from '@/layouts/MainLayout';
import DocumentUploadPage from '@/pages/Documents/Upload';
import DocumentListPage from '@/pages/Documents/List';
import DocumentDetailPage from '@/pages/Documents/Detail';
import LoginPage from '@/pages/Auth/Login';
import PrivateRoute from '@/components/Auth/PrivateRoute';

const AppRouter = () => {
  return (
    <Routes>
      <Route path="/login" element={<LoginPage />} />
      
      <Route path="/" element={<PrivateRoute><MainLayout /></PrivateRoute>}>
        <Route index element={<Navigate to="/documents" replace />} />
        
        <Route path="documents">
          <Route index element={<DocumentListPage />} />
          <Route path="upload" element={<DocumentUploadPage />} />
          <Route path=":documentId" element={<DocumentDetailPage />} />
        </Route>
      </Route>
      
      <Route path="*" element={<Navigate to="/" replace />} />
    </Routes>
  );
};

export default AppRouter;
```

#### 2. 前端环境配置

**位置**: `notebook-frontend/.env`

```
REACT_APP_API_URL=http://localhost:8000/api
REACT_APP_WS_URL=ws://localhost:8000
```

#### 3. 生产环境构建配置

**位置**: `notebook-frontend/package.json`添加脚本

```json
{
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }
}
```

### 四、第三阶段实施步骤

1. 实现API路由
   1.1. 实现任务API路由
   1.2. 实现文档API路由
   1.3. 集成WebSocket路由

2. 实现前端组件
   2.1. 实现文件上传组件
   2.2. 实现任务进度监控组件
   2.3. 实现WebSocket钩子
   2.4. 实现API调用服务

3. 实现文档上传页面
   3.1. 集成文件上传组件
   3.2. 集成任务进度监控组件
   3.3. 处理上传成功后的页面转换

4. 前端应用集成
   4.1. 配置前端路由
   4.2. 配置环境变量
   4.3. 配置构建脚本

### 五、测试验证

1. API端点测试
   - 测试文档上传API
   - 测试任务查询API
   - 测试任务详情API
   - 测试任务取消API

2. 前端组件测试
   - 测试文件上传组件
   - 测试任务进度监控组件
   - 测试WebSocket连接和通信

3. 集成测试
   - 测试完整的文档上传流程
   - 测试任务状态实时更新
   - 测试页面导航和状态保持

4. 跨浏览器兼容性测试
   - Chrome
   - Firefox
   - Safari
   - Edge 
# 文档处理任务流程实现计划 - 前端部分

## 前端组件实现

### 1. 文件上传组件（前端）

**位置**: `notebook-frontend/src/components/DocumentUpload/`

```jsx
// FileUpload.jsx
import React, { useState } from 'react';
import { Upload, Button, message, Progress } from 'antd';
import { UploadOutlined } from '@ant-design/icons';
import { uploadDocument } from '@/api/documents';

const FileUpload = ({ onUploadSuccess }) => {
  const [uploading, setUploading] = useState(false);
  const [fileList, setFileList] = useState([]);
  const [progress, setProgress] = useState(0);

  const handleUpload = async () => {
    const formData = new FormData();
    fileList.forEach(file => {
      formData.append('file', file);
    });

    setUploading(true);
    setProgress(0);

    try {
      // 调用上传API
      const response = await uploadDocument(formData, (progressEvent) => {
        const percentCompleted = Math.round(
          (progressEvent.loaded * 100) / progressEvent.total
        );
        setProgress(percentCompleted);
      });

      setFileList([]);
      setProgress(100);
      message.success('文件上传成功');
      
      // 触发父组件的成功回调
      if (onUploadSuccess) {
        onUploadSuccess(response.data);
      }
    } catch (error) {
      message.error('文件上传失败');
      console.error('上传错误:', error);
    } finally {
      setUploading(false);
    }
  };

  const props = {
    onRemove: file => {
      setFileList(fileList.filter(item => item.uid !== file.uid));
    },
    beforeUpload: file => {
      setFileList([...fileList, file]);
      return false;
    },
    fileList,
  };

  return (
    <div className="upload-container">
      <Upload {...props}>
        <Button icon={<UploadOutlined />}>选择文件</Button>
      </Upload>
      
      {fileList.length > 0 && (
        <>
          <Button
            type="primary"
            onClick={handleUpload}
            disabled={fileList.length === 0 || uploading}
            loading={uploading}
            style={{ marginTop: 16 }}
          >
            {uploading ? '上传中...' : '开始上传'}
          </Button>
          
          {uploading && <Progress percent={progress} />}
        </>
      )}
    </div>
  );
};

export default FileUpload;
```

### 2. 任务进度监控组件（前端）

**位置**: `notebook-frontend/src/components/TaskMonitor/`

```jsx
// TaskProgressMonitor.jsx
import React, { useEffect, useState } from 'react';
import { Card, Progress, Steps, Tag, Typography, Alert } from 'antd';
import { CheckCircleOutlined, CloseCircleOutlined, LoadingOutlined } from '@ant-design/icons';
import { getTaskDetails } from '@/api/tasks';
import useWebSocket from '@/hooks/useWebSocket';

const { Step } = Steps;
const { Text, Title } = Typography;

const TaskProgressMonitor = ({ taskId }) => {
  const [taskDetails, setTaskDetails] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [overallProgress, setOverallProgress] = useState(0);
  const [currentStep, setCurrentStep] = useState(0);

  // 使用WebSocket监听任务更新
  const { lastMessage } = useWebSocket(
    `${process.env.REACT_APP_WS_URL}/ws/tasks/${taskId}`
  );

  // 初始加载任务详情
  useEffect(() => {
    const fetchTaskDetails = async () => {
      try {
        setLoading(true);
        const response = await getTaskDetails(taskId);
        setTaskDetails(response.data.task_details || []);
        
        // 计算总体进度和当前步骤
        calculateProgress(response.data.task_details);
        
        setLoading(false);
      } catch (err) {
        setError('加载任务详情失败');
        setLoading(false);
        console.error('获取任务详情错误:', err);
      }
    };

    if (taskId) {
      fetchTaskDetails();
    }
  }, [taskId]);

  // 监听WebSocket消息
  useEffect(() => {
    if (lastMessage) {
      try {
        const data = JSON.parse(lastMessage.data);
        if (data.task_id === taskId) {
          // 更新任务详情
          setTaskDetails(data.task_details || []);
          
          // 计算总体进度和当前步骤
          calculateProgress(data.task_details);
        }
      } catch (err) {
        console.error('解析WebSocket消息错误:', err);
      }
    }
  }, [lastMessage, taskId]);

  // 计算总体进度和当前步骤
  const calculateProgress = (details) => {
    if (!details || details.length === 0) return;
    
    // 计算总体进度
    const totalProgress = details.reduce((sum, item) => sum + (item.progress || 0), 0) / details.length;
    setOverallProgress(Math.round(totalProgress));
    
    // 确定当前步骤
    const runningStepIndex = details.findIndex(item => item.status === 'RUNNING');
    if (runningStepIndex >= 0) {
      setCurrentStep(runningStepIndex);
    } else {
      // 如果没有正在运行的步骤，则查找最后一个已完成的步骤
      const lastCompletedIndex = details
        .map((item, index) => ({ status: item.status, index }))
        .filter(item => item.status === 'COMPLETED')
        .map(item => item.index)
        .pop();
        
      if (lastCompletedIndex !== undefined) {
        setCurrentStep(lastCompletedIndex + 1);
      }
    }
  };

  // 获取步骤状态图标
  const getStepIcon = (status) => {
    switch (status) {
      case 'COMPLETED':
        return <CheckCircleOutlined style={{ color: '#52c41a' }} />;
      case 'FAILED':
        return <CloseCircleOutlined style={{ color: '#f5222d' }} />;
      case 'RUNNING':
        return <LoadingOutlined />;
      default:
        return null;
    }
  };

  // 获取步骤状态标签
  const getStatusTag = (status) => {
    switch (status) {
      case 'PENDING':
        return <Tag color="default">等待中</Tag>;
      case 'RUNNING':
        return <Tag color="processing">处理中</Tag>;
      case 'COMPLETED':
        return <Tag color="success">已完成</Tag>;
      case 'FAILED':
        return <Tag color="error">失败</Tag>;
      default:
        return <Tag>{status}</Tag>;
    }
  };

  if (loading) return <div>加载任务进度...</div>;
  if (error) return <Alert type="error" message={error} />;

  return (
    <Card title="文档处理进度" bordered={false}>
      <div style={{ marginBottom: 20 }}>
        <Title level={5}>总体进度</Title>
        <Progress percent={overallProgress} status={overallProgress === 100 ? 'success' : 'active'} />
      </div>
      
      <Steps current={currentStep} direction="vertical">
        {taskDetails.map((step, index) => (
          <Step
            key={index}
            title={step.step_name}
            description={
              <div>
                {getStatusTag(step.status)}
                {step.status === 'RUNNING' && (
                  <Progress percent={step.progress} size="small" style={{ marginTop: 8 }} />
                )}
                {step.error_message && (
                  <Text type="danger" style={{ display: 'block', marginTop: 8 }}>
                    错误: {step.error_message}
                  </Text>
                )}
              </div>
            }
            icon={getStepIcon(step.status)}
          />
        ))}
      </Steps>
    </Card>
  );
};

export default TaskProgressMonitor;
```

### 3. WebSocket钩子（前端）

**位置**: `notebook-frontend/src/hooks/useWebSocket.js`

```javascript
import { useEffect, useState, useRef } from 'react';

const useWebSocket = (url) => {
  const [isConnected, setIsConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState(null);
  const [error, setError] = useState(null);
  const webSocketRef = useRef(null);

  useEffect(() => {
    // 创建WebSocket连接
    const socket = new WebSocket(url);
    webSocketRef.current = socket;

    // 连接事件处理
    socket.onopen = () => {
      setIsConnected(true);
      setError(null);
    };

    // 消息接收处理
    socket.onmessage = (event) => {
      setLastMessage(event);
    };

    // 错误处理
    socket.onerror = (event) => {
      setError('WebSocket连接错误');
      console.error('WebSocket错误:', event);
    };

    // 连接关闭处理
    socket.onclose = () => {
      setIsConnected(false);
    };

    // 清理函数
    return () => {
      socket.close();
    };
  }, [url]);

  // 发送消息方法
  const sendMessage = (data) => {
    if (webSocketRef.current && isConnected) {
      webSocketRef.current.send(typeof data === 'string' ? data : JSON.stringify(data));
    } else {
      setError('WebSocket未连接，无法发送消息');
    }
  };

  return { isConnected, lastMessage, error, sendMessage };
};

export default useWebSocket;
```

### 4. API服务（前端）

**位置**: `notebook-frontend/src/api/documents.js`

```javascript
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

// 上传文档
export const uploadDocument = (formData, onProgress) => {
  return axios.post(`${API_URL}/documents/upload`, formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
    onUploadProgress: onProgress,
  });
};

// 获取文档列表
export const getDocuments = (page = 1, limit = 10) => {
  return axios.get(`${API_URL}/documents`, {
    params: { page, limit },
  });
};

// 获取文档详情
export const getDocumentById = (documentId) => {
  return axios.get(`${API_URL}/documents/${documentId}`);
};
```

**位置**: `notebook-frontend/src/api/tasks.js`

```javascript
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

// 获取任务列表
export const getTasks = (page = 1, limit = 10) => {
  return axios.get(`${API_URL}/tasks`, {
    params: { page, limit },
  });
};

// 获取任务详情
export const getTaskById = (taskId) => {
  return axios.get(`${API_URL}/tasks/${taskId}`);
};

// 获取任务步骤详情
export const getTaskDetails = (taskId) => {
  return axios.get(`${API_URL}/tasks/${taskId}/details`);
};

// 取消任务
export const cancelTask = (taskId) => {
  return axios.post(`${API_URL}/tasks/${taskId}/cancel`);
};
```

### 5. 文档上传页面（前端）

**位置**: `notebook-frontend/src/pages/Documents/Upload.jsx`

```jsx
import React, { useState } from 'react';
import { Card, message, Result, Button } from 'antd';
import { useNavigate } from 'react-router-dom';
import FileUpload from '@/components/DocumentUpload/FileUpload';
import TaskProgressMonitor from '@/components/TaskMonitor/TaskProgressMonitor';

const DocumentUploadPage = () => {
  const [uploadedTask, setUploadedTask] = useState(null);
  const navigate = useNavigate();

  const handleUploadSuccess = (data) => {
    setUploadedTask(data);
    message.success('文件已成功上传，正在处理中');
  };

  const handleViewDocuments = () => {
    navigate('/documents');
  };

  return (
    <div className="document-upload-page">
      <Card title="上传文档" bordered={false}>
        {!uploadedTask ? (
          <FileUpload onUploadSuccess={handleUploadSuccess} />
        ) : (
          <div>
            <Result
              status="success"
              title="文件上传成功!"
              subTitle="文件正在处理中，请等待处理完成。"
              extra={[
                <Button type="primary" key="documents" onClick={handleViewDocuments}>
                  查看所有文档
                </Button>,
              ]}
            />
            <TaskProgressMonitor taskId={uploadedTask.task_id} />
          </div>
        )}
      </Card>
    </div>
  );
};

export default DocumentUploadPage;
```

## WebSocket服务实现（后端）

**位置**: `notebook-backend/app/websockets/task_manager.py`

```python
import json
import logging
from typing import Dict, List, Any, Optional
from fastapi import WebSocket, WebSocketDisconnect
from app.models.task import Task, TaskDetail

logger = logging.getLogger(__name__)

class ConnectionManager:
    """WebSocket连接管理器"""
    
    def __init__(self):
        self.active_connections: Dict[str, List[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, task_id: str):
        """添加新的WebSocket连接"""
        await websocket.accept()
        if task_id not in self.active_connections:
            self.active_connections[task_id] = []
        self.active_connections[task_id].append(websocket)
        logger.info(f"新的WebSocket连接: {task_id}, 当前连接数: {len(self.active_connections[task_id])}")
    
    def disconnect(self, websocket: WebSocket, task_id: str):
        """移除WebSocket连接"""
        if task_id in self.active_connections:
            if websocket in self.active_connections[task_id]:
                self.active_connections[task_id].remove(websocket)
            # 如果没有活跃连接，则移除任务ID
            if not self.active_connections[task_id]:
                del self.active_connections[task_id]
            logger.info(f"WebSocket连接断开: {task_id}, 剩余连接数: {len(self.active_connections.get(task_id, []))}")
    
    async def broadcast_task_update(self, task_id: str, data: Dict[str, Any]):
        """广播任务更新消息"""
        if task_id in self.active_connections:
            # 序列化数据为JSON字符串
            message = json.dumps(data)
            for connection in self.active_connections[task_id]:
                try:
                    await connection.send_text(message)
                except Exception as e:
                    logger.error(f"发送WebSocket消息失败: {str(e)}")
    
    async def send_personal_message(self, websocket: WebSocket, message: str):
        """发送个人消息"""
        try:
            await websocket.send_text(message)
        except Exception as e:
            logger.error(f"发送个人WebSocket消息失败: {str(e)}")


# 创建全局连接管理器实例
connection_manager = ConnectionManager()


async def task_websocket_endpoint(websocket: WebSocket, task_id: str):
    """任务WebSocket端点"""
    await connection_manager.connect(websocket, task_id)
    try:
        while True:
            # 等待前端消息（虽然在这个应用中前端可能不发送消息）
            data = await websocket.receive_text()
            # 对接收到的消息做处理，通常是控制命令
            await handle_websocket_message(websocket, task_id, data)
    except WebSocketDisconnect:
        connection_manager.disconnect(websocket, task_id)


async def handle_websocket_message(websocket: WebSocket, task_id: str, message: str):
    """处理从WebSocket接收到的消息"""
    try:
        data = json.loads(message)
        command = data.get("command")
        
        if command == "ping":
            # 心跳检测
            await connection_manager.send_personal_message(websocket, json.dumps({"command": "pong"}))
        elif command == "cancel":
            # 取消任务
            # TODO: 实现任务取消逻辑
            pass
        else:
            # 未知命令
            await connection_manager.send_personal_message(
                websocket, 
                json.dumps({"error": "Unknown command"})
            )
    except json.JSONDecodeError:
        await connection_manager.send_personal_message(
            websocket, 
            json.dumps({"error": "Invalid JSON format"})
        )
    except Exception as e:
        logger.error(f"处理WebSocket消息时出错: {str(e)}")
        await connection_manager.send_personal_message(
            websocket, 
            json.dumps({"error": f"Internal error: {str(e)}"})
        )


async def push_task_update(task_id: str, task_service, task_detail_service=None):
    """推送任务更新到WebSocket客户端"""
    try:
        # 获取任务信息
        task = task_service.get_task_by_id(task_id)
        if not task:
            logger.error(f"推送任务更新失败: 任务 {task_id} 不存在")
            return
        
        # 获取任务详情
        task_details = []
        if task_detail_service:
            task_details = task_detail_service.get_task_details_by_task_id(task_id)
        
        # 准备数据
        task_data = {
            "task_id": task.id,
            "status": task.status,
            "progress": task.progress,
            "error_message": task.error_message,
            "task_details": [
                {
                    "id": detail.id,
                    "step_name": detail.step_name,
                    "step_order": detail.step_order,
                    "status": detail.status,
                    "progress": detail.progress,
                    "error_message": detail.error_message,
                    "started_at": detail.started_at.isoformat() if detail.started_at else None,
                    "completed_at": detail.completed_at.isoformat() if detail.completed_at else None
                }
                for detail in task_details
            ] if task_details else []
        }
        
        # 广播更新
        await connection_manager.broadcast_task_update(task_id, task_data)
        
    except Exception as e:
        logger.error(f"推送任务更新失败: {str(e)}")
```

## API路由实现（后端）

**位置**: `notebook-backend/app/api/endpoints/tasks.py`

```python
from fastapi import APIRouter, Depends, HTTPException, Query, WebSocket
from sqlalchemy.orm import Session
from typing import List, Optional
from app.database import get_db
from app.models.task import TaskCreate, TaskStatusResponse, TaskDetail, TaskList
from app.services.task_service import TaskService
from app.services.task_detail_service import TaskDetailService
from app.websockets.task_manager import task_websocket_endpoint, push_task_update
from app.auth.auth import get_current_user
from app.models.user import User

router = APIRouter()

@router.get("", response_model=TaskList)
async def get_tasks(
    page: int = Query(1, gt=0),
    limit: int = Query(10, gt=0),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取任务列表"""
    task_service = TaskService(db)
    tasks, total = task_service.get_tasks(
        created_by=current_user.id,
        page=page,
        limit=limit
    )
    return TaskList(tasks=tasks, total=total)

@router.get("/{task_id}", response_model=TaskStatusResponse)
async def get_task(
    task_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取任务详情"""
    task_service = TaskService(db)
    task = task_service.get_task_by_id(task_id)
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    # 验证用户权限
    if task.created_by != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view this task")
    
    return task

@router.get("/{task_id}/details")
async def get_task_details(
    task_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取任务步骤详情"""
    task_service = TaskService(db)
    task_detail_service = TaskDetailService(db)
    
    task = task_service.get_task_by_id(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    # 验证用户权限
    if task.created_by != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view this task")
    
    task_details = task_detail_service.get_task_details_by_task_id(task_id)
    
    return {
        "task_id": task_id,
        "task_details": task_details
    }

@router.post("/{task_id}/cancel", response_model=TaskStatusResponse)
async def cancel_task(
    task_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """取消任务"""
    task_service = TaskService(db)
    
    task = task_service.get_task_by_id(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    # 验证用户权限
    if task.created_by != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to cancel this task")
    
    task = task_service.cancel_task(task_id)
    
    # 推送更新到WebSocket
    await push_task_update(task_id, task_service)
    
    return task

@router.websocket("/ws/tasks/{task_id}")
async def websocket_task_endpoint(
    websocket: WebSocket,
    task_id: str,
    db: Session = Depends(get_db)
):
    """任务WebSocket端点"""
    await task_websocket_endpoint(websocket, task_id)
```

**位置**: `notebook-backend/app/api/endpoints/documents.py`

```python
from fastapi import APIRouter, Depends, File, UploadFile, Form, HTTPException, Query
from sqlalchemy.orm import Session
from typing import Optional, Dict, Any
import json
import uuid
from datetime import datetime
import os

from app.database import get_db
from app.models.document import DocumentCreate, DocumentResponse, DocumentList
from app.models.task import TaskStatus
from app.services.document_service import DocumentService
from app.services.task_service import TaskService
from app.services.storage_service import StorageService
from app.celery_tasks.document_processing import process_document
from app.auth.auth import get_current_user
from app.models.user import User

router = APIRouter()

@router.post("/upload", response_model=DocumentResponse)
async def upload_document(
    file: UploadFile = File(...),
    metadata: Optional[str] = Form(None),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """上传文档"""
    # 初始化服务
    document_service = DocumentService(db)
    task_service = TaskService(db)
    storage_service = StorageService()
    
    # 处理元数据
    doc_metadata = {}
    if metadata:
        try:
            doc_metadata = json.loads(metadata)
        except Exception as e:
            raise HTTPException(status_code=400, detail=f"Invalid metadata: {str(e)}")
    
    try:
        # 保存文件到临时目录
        temp_file_path = await storage_service.save_upload_file_temp(file)
        
        # 生成唯一文件名
        filename = file.filename or "unnamed_file"
        file_extension = os.path.splitext(filename)[1].lower() if filename else ""
        object_key = f"{current_user.id}/{uuid.uuid4()}/{filename}"
        
        # 创建文档记录（状态为处理中）
        document = document_service.create_document(
            DocumentCreate(
                name=filename,
                file_type=file_extension.lstrip(".") or file.content_type,
                doc_metadata=doc_metadata,
                user_id=current_user.id,
                processing_status="PROCESSING"
            )
        )
        
        # 创建任务记录
        task = task_service.create_task(
            name=f"处理文档: {filename}",
            task_type="DOCUMENT_PROCESSING",
            description=f"从文件 {filename} 中提取文本并生成向量",
            created_by=current_user.id,
            document_id=document.id,
            metadata={
                "filename": filename,
                "content_type": file.content_type,
                "upload_time": datetime.utcnow().isoformat(),
                "temp_file_path": temp_file_path,
                "object_key": object_key
            }
        )
        
        # 启动Celery任务
        process_document.delay(document.id, task.id, temp_file_path)
        
        # 将任务ID添加到文档记录
        document = document_service.update_document(document.id, {"task_id": task.id})
        
        return document
        
    except Exception as e:
        # 出现异常时清理资源
        raise HTTPException(status_code=500, detail=f"Failed to upload document: {str(e)}")

@router.get("", response_model=DocumentList)
async def get_documents(
    page: int = Query(1, gt=0),
    limit: int = Query(10, gt=0),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取文档列表"""
    document_service = DocumentService(db)
    documents, total = document_service.get_documents(
        user_id=current_user.id,
        page=page,
        limit=limit
    )
    return DocumentList(documents=documents, total=total)

@router.get("/{document_id}", response_model=DocumentResponse)
async def get_document(
    document_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取文档详情"""
    document_service = DocumentService(db)
    document = document_service.get_document_by_id(document_id)
    
    if not document:
        raise HTTPException(status_code=404, detail="Document not found")
    
    # 验证用户权限
    if document.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to view this document")
    
    return document
``` 